[{"title":"实变函数","url":"/2022/06/22/实变函数/","content":"西安交通大学**实变函数**(2022 Spring)课程笔记。<!--more-->\n\n## 说明\n\n笔记中包含许多错误和不妥之处，请谨慎使用。\n\n## PDF文件\n\n[[PDF]](./实变函数.pdf)\n\n{% pdf ./实变函数.pdf %}","tags":["复习","实变函数"],"categories":["数学"]},{"title":"C语言学习笔记","url":"/2022/02/21/C语言学习笔记/","content":"\n这是我在准备**大学计算机**(2021 Fall)期末考试时编写的文档，主要整理总结课程中**C语言**部分的知识点。<!--more-->课本为吴宁主编的《大学计算机》。文中引用的题目为“课程作业平台”上的题目（在GitHub上有老师编写的[答案](https://github.com/AndrewChui/CHomeWork))。\n\n## 重要的题目\n\n下划线代表比较困难的题目。\n* **week 8** 04 05 <u>07</u> 09\n* **week 9** 02 06 <u>07</u> 08 10\n* **week 10** 02 <u>03</u> 05 <u>06</u> 10\n* **week 11** 01 <u>03</u> 05 10\n* **week 12** 01 04 06 09\n* **week 13** 01 <u>04</u> <u>06</u> 07\n* **week 14** 01 <u>04</u> <u>06</u> <u>08</u>\n\n## 注意事项\n\n下面整理一些知识点以及需要注意的地方。\n1. `scanf()`格式，`(void)scanf(\"%d\",&a);`不要忘记`\"\"`和`&`（对于数组不用加`&`）\n2. 判断用`==`，赋值用`=`\n3. `for`，`while`，`if`等后不用分号\n4. 字符串的比较，**赋值**等，不能用`=`，要用string库函数`strcmp`，`strcpy`等\n5. 函数要先定义(声明)后使用\n7. 注意区间的写法(`x>1&&x<6`)\n8. 判断一个字符`c`是否是大写字母(`c>='A' && c<='Z'`)\n9. 逻辑运算(如`&`)是从左到右进行的，如果左边的结果已经能够决定结果了，就不会进行右边的运算\n9. <mark>初始化字符串</mark> `char s[100] = { 0 };`，在初始化数组时全部置0可以避免出现警告“可能没有为字符串添加终止符”。其他类型的数组不用初始化。\n10. “烫烫烫”的问题：按照`%s`输出字符串的时候,遇到了未初始化的空间\n    * 注意初始化字符串( `char s[100] = { 0 };` )\n    * 注意在字符串末尾加上终止符`'\\0'`\n11. 若要对字符串元素依次赋值(数字)，要注意将 4变为`'4'` (加偏移 4+`'0'`)\n12. “屯屯屯”的问题：使用动态分配时出现错误\n    * 注意在字符串末尾加上终止符`'\\0'`\n13. 宏定义`#define`\n14. 对复杂类型进行排序，建议写成结构体\n16. 用`scanf`即可，不要用`scanf_s`，使用时为`(void)scanf();`\n17. 掌握冒泡排序和选择排序（会写代码）\n    * 掌握快排的思想，可能出选择题\n18. 时间充足的话，整理代码，尽量把功能写成函数（如排序算法）\n    * 函数前注意写注释（用`///`）\n19. 函数原型后有分号\n20. 注意文件后缀为.c不是.cpp\n21. 使用结构体时最好使用`typedef`，后面使用方便。例如：`typedef int DateType;`可用`DateType`代替`int`\n22. `arr+i` 与 `&arr[i]` 意义相同\n    `*(arr+i)` 与 `arr[i]` 意义相同\n23. 看顺序表的mooc\n24. 综合填空题的范围：顺序表，栈，队列\n25. 要去掉小数后多余的0，使用`%g`的格式打印\n\n    ```c\n    double a = 1.2;\n    \n    printf(\"%lf\\n\", a); //输出：1.200000\n    printf(\"%f\\n\", a); //输出：1.200000\n    printf(\"%g\\n\", a); //输出：1.2 去掉了小数后多余的0\n    printf(\"%d\\n\", (int)a); //输出：1 必须先加上强制转换，才能用%d格式输出，否则会报错\n    printf(\"%lf\\n\", a); //输出：1.200000 这说明了强制转换只是暂时的\n    ```\n\n26. 类型的强制转换（见课本P176）。例如：如果`i`的类型为int，则`(double) i`将`i`转换为double型\n    *注意：强制类型转换操作并不改变操作数本身，运算后操作数本身未改变。*\n\n27. 求余运算`%`两侧应均为int型。例如：`5 % 3 = 2`\n    关于取余：任何一个整数 $n$ 都可以表示成 $n=k\\times q+r$ 其中 $0\\leq|r|<|q|$ 这里的 $r$ 就是 $n$ 除以 $q$ 的余数，即 `r = n % q`。由此可以知道<mark>负数取余</mark>的相关规律，例如：$-9=(-2)\\times 4+(-1)$则$-9$除以$4$的余数为$-1$。\n\n    ```c\n    printf(\"%d\\n\", 7 % (-5)); //2\n    printf(\"%d\\n\", (-7) % (-5)); //-2\n    printf(\"%d\\n\", (-9) % 4); //-1\n    printf(\"%d\\n\", (-123) % 10); //-3\n    printf(\"%d\\n\", (-123) % (-10)); //-3\n    ```\n\n28. <mark>int型输出的格式控制</mark>\n    * `%d`输出普通的整数\n    * `%2d`是将数字按宽度为2，采用右对齐方式输出，若数据位数不到2位，则左边补空格。\n    * `%02d`与`%2d`相似，区别是左边补0\n    * `%.2d`从执行效果来看，和`%02d`一样\n\n    ```c\n    int a = 1;\n    printf(\"%d\\n\", a); //结果为1\n    printf(\"%2d\\n\", a); //结果为 1\n    printf(\"%.2d\\n\", a); //结果为01\n    printf(\"%02d\\n\", a); //结果为01\n    ```\n\n29. `float`：单精度浮点型，占用4个字节，有7位有效数字；`double`：双精度浮点型，占用8个字节，有15位有效数字。使用`%f`和`%lf`输出时，都默认保留6位小数。\n\n    ```c\n    float a = 123456789.12345;\n    double b = 123456789.12345;\n    printf(\"%f\", a); //输出：123456792.000000 可以看到超过有效数字位数则不准确\n    printf(\"%lf\", b); //输出：123456789.123450 准确\n    ```\n\n29. <mark>float型及double型输出的格式控制</mark>\n    * `%f`和`%lf`输出普通的小数\n    * `%.2f`和`%.2lf`保留两位小数。一般地，`%.mf`和`%.mlf`表示保留m位小数。\n\n31. **静态变量**的特点是在程序开始运行之前就为其分配了相应的存储空间，在程序的整个运行期间静态变量一直占用着这些存储空间，直到整个程序运行结束。\n\n    ```c\n    int func()\n    {\n        static int count = 0; //静态变量count\n        return ++count;\n    }\n    ```\n\n    静态局部变量`count`只能在其定义域（`func`）内使用，但其生存周期却与整个程序的运行期相同。主程序在离开韩顺`func`后`count`占用的存储空间并不释放，*其中的内容也就不会发生改变*。\n\n32. 字母可用数字表示（ASCII码）\n\n    ```C\n    printf(\"%d\\n\", 'A'); //结果是65\n    printf(\"%c%c%c\", 'S' - 1, 'S', 'S' + 1); //结果是RST\n    ```\n\n33. <mark>ASCII码</mark>（见课本P367）*注意记住这个顺序：*\n    ……`'0'`(48) ~ `'9'` (57)…… `'A'` (65) ~ `'Z'` (90)…… `'a'` (97) ~ `'z'` (122)……\n\n    ```c\n    char c;\n    (c < 'A') || ('Z' < c && c < 'a') || (c > 'z') //c不是字母\n    ```\n\n34. 代码中有循环的计数要特别注意，防止重复计数（如week8第8题）\n\n35. `switch`控制结构\n\n    ```c\n    int a, grade;\n    \n    switch (a/10) //括号中是一个整型表达式。执行switch时先计算这个表达式，将值与各case后的常量依次比较。\n    {\n    case 10:\n    case 9:\n    \tgrade = 5;\n    \tbreak; //不要忘记加break，跳出switch循环。不加的话会继续执行后面的case模块。\n    case 8:\n    \tgrade = 4;\n    \tbreak;\n    //\n    default: //如果整型表达式的值与所有case模块的进入值无一相同，则执行default模块中的语句。\n    \tgrade = 1;\n    \tbreak;\n    }\n    ```\n\n36. 二维数组，如`int matrix[3][4]`说明了一个3行4列的整型矩阵。详见课本P204。允许省略行下标，不能省略列下标。\n    对于二维字符数组：\n\n    ```C\n    char c[3][8] = {\"Apple\",\"Orange\",\"Pear\"}; //初始化数组\n    \n    //注意：行和列都是从0开始计数\n    printf (\"%c\",c[1][4]); //输出1行4列元素'g'字符\n    scanf (\"%c\",&c[2][3]); //输入一个字符到2行3列元素中\n    c[2][0]='B'; //把字符赋值给2行0列元素\n    printf (\"%s\",c[1]); //c[1]为第2行的数组名（首元素地址），输出 Orange\n    scanf (\"%s\",c[2]); //输入字符串到c[2]行，从c[2]行的首地址开始存放\n    ```\n\n37. 关于月份和天数：\n    * 1月，3月，5月，7月，8月，10月，12月有31天；\n    * 4月，6月，9月，11月有30天；\n    * 2月要区分是否为<mark>闰年</mark>，闰年为29天，普通年份为28天。\n\n    >  闰年：四年一闰，百年不闰，四百年再闰。\n    >\n    > * 普通闰年：公历年份<u>是4的倍数，且不是100的倍数</u>的，为闰年（如2004年、2020年等就是闰年）\n    >\n    > * 世纪闰年：公历年份是整百数的，必须<u>是400的倍数</u>才是闰年（如1900年不是闰年，2000年是闰年）\n\n    判断是否是闰年的算法如下：\n\n    ```c\n    if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)//为闰年的条件 \n    {\n    \tprintf(\"%d是闰年\\n\", year);\n    }\n    else\n    {\n    \tprintf(\"%d不是闰年\\n\", year);\n    }\n    ```\n    \n38. 关于字符串的输入：一般用`scanf`，如果字符串包含空格，需要用`gets`。`gets`函数只有一个参数，如语句`gets(name);`。\n    关于字符串的输出：一般用`printf(\"%s\", name);`，如果对格式没要求，可以直接用`printf(name);`，也可用`puts(name);`，需要注意`puts`会自动换行。\n\n39. <mark>问号表达式</mark>。详见课本P169\n    `<1> ? <2> : <3>;` 如果`<1>`的值非零，则问号表达式的值就是`<2>`的值；如果`<1>`的值为零，则问号表达式的值就是`<3>`的值。\n\n40. `goto`表达式：C语言可在语句前面放置一个标号，一般格式为`<标号>: <语句>;`，例如`End: return x;`。加上标号的主要目的是使用`goto`语句。`goto`语句的格式为`goto <标号>;`，例如`goto End;`。\n    `goto`语句只能在本函数模块内使用。*在考试中尽量不要用`goto`语句，可能会扣分。*\n\n41. `break;`语句结束整个循环；`continue;`语句只结束本次循环，接着进入下一次是否执行循环的判断。\n    一个例子：<mark>week13第7题</mark>\n\n42. `while`先判断后执行；`do-while`先执行后判断。详见课本P183。\n\n43. 函数原型中以数组为参数，格式如`void count(char string[], char character)`。\n    调用函数并传参时格式如`count(string, character)`。*注意数组的写法。*\n    在声明数组形参时，`int a[]`与`int* a`是一样的。\n\n44. `sizeof()`是一个单目操作符，不是一个函数。其作用是求出对象在计算机内存中所占用的*字节数*。\n\n    ```c\n    int a = 100;\n    printf(\"%d\", sizeof(a)); //结果是4 表明一个int型占四个字节\n    \n    int array[] = { 1, 3, 5, 7, 9 }; //可以省略数组长度\n    //数组长度可由 sizeof(array)/sizeof(int) 得到\n    ```\n    \n45. 算法实现所耗费的时间，即**时间复杂度**。算法实现所消耗的存储空间，即**空间复杂度**。\n\n46. 数组（字符型数组除外）的输入要用`for`循环逐个输入，这就是为什么涉及数组的题目常常要先给出数组长度。\n\n    ```c\n    int A[100];\n    int n = 50; //给定n的值\n    for (int i = 0; i < n; i++)\n    {\n        (void)scanf(\"%d\", &A[i]);\n    }\n    ```\n    \n47. 关于`for`循环：\n\n    ```c\n    for (<表达式1>; <表达式2>; <表达式3>)\n    {\n    \t<循环体>\n    }\n    ```\n\n    执行顺序：\n    * 先执行`<表达式1>`\n    * 再执行`<表达式2>`（<mark>注意</mark>：第一次循环前就会执行`<表达式2>`，只有满足条件才进入循环体）\n      * 若满足`<表达式2>`，则进入循环体，之后再执行`<表达式3>`，然后再进行`<表达式2>`的判断\n      * 若不满足`<表达式2>`，则结束循环\n\n48. 对于一个函数，`return <>;`后的语句不执行，函数执行结束。\n\n49. **质数**又称**素数**。一个大于1的自然数，除了1和它自身外，不能被其他自然数整除，则这个数叫做质数；否则称为合数。（规定1既不是质数也不是合数）\n\n50. 对字符串操作时，要<mark>巧用库函数</mark>，如`strcat()`，比如week12第9题，在一个字符串前面补`'0'`\n\n51. **等差数列**的通项公式和前$n$项和公式\n\n    $$\n    a_n=a_1+(n-1)d\\\\\\\\\n    S_n=na_1+\\frac{n(n-1)}{2}d=\\frac{n(a_1+a_n)}{2}\n    $$\n\n    **等比数列**的通项公式和前$n$项和公式\n\n    $$\n    a_n=a_1q^{n-1}\\\\\\\\\n    S_n=\\frac{a_1(1-q^n)}{1-q}=\\frac{a_1-a_nq}{1-q}\n    $$\n    \n52. 通过指针访问结构体的成员要用箭头操作符`->`，详见课本P262\n\n53. **栈**是一种只能在某一端进行操作的特殊线性表。先进后出。<em>栈顶指向栈顶元素之后的空位置。</em>栈的大小为“栈顶-栈底”`stack->top - stack->bottom`。若栈顶=栈底，为空栈。若栈顶=栈大小，为满栈。\n    **队列**是一种只能在表的一端进行插入操作、另一端进行删除操作的特殊线性表。先进先出。<em>队头指向存放实际队头元素的前一个位置。</em>队列长度为“队尾-队头”`queue->rear - queue->front`。对于循环队列，当队尾和队头重叠时，队列为空。随着不断的出队入队，队列向“右”移动。\n\n54. 数据的**逻辑结构**：集合、线性、非线性（树、图）\n    数据的**存储结构**：顺序、链式、索引、散列\n\n## 常用的函数\n\n### 数学函数\n\n需要加上`#include<math.h>`。以下的`a`可以是int型，float型，double型。\n\n#### 开根号\n\n`x=sqrt(a);`\n\n#### 取整\n\n向下取整`x=floor(a);`向上取整`x=ceil(a);`\n\n#### 四舍五入\n\n`x=round(a);`\n\n#### 对数函数\n\n`x=log(a)`，以e为底的对数。`x=log10(a)`，以10为底的对数。\n\n#### 幂函数\n\n$x^y$可用`pow(x,y)`计算，其中`x`和`y`均为double型，得到的结果也是double型。\n\n#### 绝对值\n\n*绝对值：absolute value* `abs(x)`求整型数据`x`的绝对值；`fabs(y)`求浮点数`y`的绝对值。\n\n### 字符串函数\n\nC提供了一组用于字符串处理的库函数。需要加上`#include<string.h>`。详见课本P208。\n\n#### `strcpy()`字符串复制\n\n*copy* `strcpy(char *destin, char *source);`，将字符串`source`的内容复制到字符型数组`destin`中。\n\n#### `strlen()`字符串长度\n\n*length* `int strlen(char *s);`，返回字符串`s`的长度，不包括字符串结束符`'\\0'`。如`\"apple\"`的长度为5。\n\n#### `strcmp()`字符串比较\n\n*compare* `int strcmp(char *string1, char *string2);`，比较两个字符串（按照字典序，即在字典中排在前面的单词<mark>小于</mark>排在其后的单词）（比较ASCII码）。\n\n* `string1`小于`string2`，返回*负整数值*。\n* `string1`等于`string2`，返回*0*。\n* `string1`大于`string2`，返回*正整数值*。\n\n#### `strcat()`连接字符串\n\n*catenate* `strcat(char *destin, char *source);`，将字符串`source`的内容复制到字符型数组`destin`中原来的字符串的后面，使两个字符串合并成一个字符串。\n\n#### `strrev`反转字符串\n\n*reverse* `char* strrev(char *string);`反转字符串，并发挥反转后的字符串的指针。要将一个字符串反转并储存在原来的字符型数组中，可以用`strcpy(string, strrev(string));`。\n\n```c\nchar s[10] = \"apple\";\nprintf(\"%s\\n\", strrev(s)); //结果是elppa\nprintf(\"%s\\n\", s); //结果是elppa，说明了字符串s中的内容已被修改\n```\n\n#### 查找字符、字符串\n\n*character* `char* strchr(char* string, char c);`其中`string`为被查找的字符串，`c`为要查找的字符。返回在字符串`string`中第一次出现字符`c`的位置（指针），如果未找到该字符`c`则返回`NULL`。\n\n*string* `char* strstr(char* string1, char* string2);`其中`string1`为被查找的字符串，`string2`为要查找的字符串。返回在字符串`string1`中第一次出现字符串`string2`的位置（指针），如果未找到该字符串则返回`NULL`。\n\n#### 大小写字母转换\n\n*lower* `strlwr(char *string);`大写变为小写；\n\n*upper* `strupr(char *string);`小写变为大写。\n\n### 动态分配函数\n\n需要加上`#include<stdlib.h>`。详见课本P258。\n\n#### 分配内存空间函数`malloc`\n\n*memory allocation* 调用形式：`(类型说明符*)malloc(size)`。该函数在内存中分配一块长度为`size`字节的连续区域。<em>“类型说明符”表示把该区域用于何种数据类型。</em>`(类型说明符*)`表示把返回值强制转换为该类型的指针。该函数返回一个指针 ，指向该区域的首地址。如果分配失败，则返回`NULL`。如`str = (char*)malloc(100);`表示分配了100个字节的内存空间。\n\n#### 分配内存空间函数`calloc`\n\n*clear allocation* 调用形式：`(类型说明符*)calloc(n, size)`。分配`n`块长度为`size`字节的连续区域。该函数与`malloc`函数的区别在与一次可以分配`n`块区域，另外，`calloc`会将分配的内存初始化为0。\n\n#### 释放内存空间函数`free`\n\n调用形式：`free(ptr);`。释放`ptr`指向的一块内存空间。<em>`ptr`是一个任意类型的指针变量，它指向被释放的区域的首地址。</em>被释放的区域应是由`malloc`或`calloc`函数分配的区域。假如`p`是一个指针，则该函数的用法是`free(p);`。\n\n## 结构体\n\n> C语言中的结构体类型适用于说明具有层次结构的复杂数据。\n\n首先，需要根据数据的具体情况*定义结构体的数据类型*。在定义了结构体类型后，即可用其*声明*该结构体的变量和数组。*详见课本P210*\n\n### 结构体类型的定义\n\n例如，可定义一个表示日期的结构体，它有3个成员变量。\n\n```c\n//定义结构体类型\nstruct _date\n{\n\tint year;\n\tint month;\n\tint day;\n}; //注意：这里有分号“;”\n\n//声明一些结构体变量\nstruct _date yeaterday;\nstruct _date today;\nstruct _date tomorrow;\n```\n\n习惯上用`typedef`将`struct _date`重新定义为一个新的名称，这样在以后的声明中就可以*简洁些*。\n\n```c\n//定义结构体类型，并将其重命名为Date\ntypedef struct _date\n{\n\tint year;\n\tint month;\n\tint day;\n}Date;\n\n//声明一些结构体变量\nDate yesterday;\nDate today;\nDate tomorrow;\n\n//常用（将struct list重定义为List）\n//定义结构体List用于储存字母及出现的次数\ntypedef struct list {\n\tchar c;\n\tint count;\n}List;\n```\n\n### 结构体类型变量的使用\n\n对结构体类型变量的成员的引用方法为`<结构体类型变量名>.<成员变量名>`。\n\n```c\ntoday.year = 2000;\ntoday.month = 1;\ntoday.day = 1;\n```\n\n和数组一样，不能将结构体变量作为一个整体输出，只能以结构体的成员作为基本变量，一次输入或输出结构体变量中的一个成员。例如：\n\n```c\nfor (int i = 0; i < n; i++)\n{\n\t(void)scanf(\"%s %s\", &input[i].name, &input[i].tele);\n}\n```\n\n### 数组和结构体\n\n*结构体的成员可以是数组*，其使用方法和简单变量相同。注意，若结构体的成员为字符型数组，不用初始化为`{0}`。\n\n*数组也可以由结构体组成*。如可以进行声明`Student xjtuStudent[30];`，这样，每一个数组元素都是一个结构体。\n\n*结构体的成员也可以是结构体*，称为嵌套结构。嵌套结构的成员访问是很简单的，对其中每个结构成员都是从外向内引用的。\n\n## 指针\n\n> C语言之所以强大以及自由，很大部分体现在其灵活的指针应用上。因此，说指针是C语言的灵魂，一点都不为过。\n\nC语言规定：\n\n* 变量的地址可以使用地址运算符`&`求得。例如，`&x`表示变量`x`的地址。\n* 数组的地址，即数组第一个元素的地址，可以直接用数组名表示。\n* 函数的地址用函数名表示。\n\n<mark>某个变量的内存地址称为该变量的**指针**。</mark>用以表示不同指针值的变量就是**指针变量**，简称**指针**。同样的，指针变量也必须先声明。\n\n```c\n//指针变量的声明形式\n<数据类型>* <指针变量名>;\n//下面是一些例子\nint* ptr; //指向int类型变量的指针（简称：int型指针）\nchar* ptr; //指向char类型变量的指针（简称：char型指针）\n```\n\n由此可以知道，函数中形如`int* ptr`的形参实际上要求用一个形如`&num`的指针作为实参。（week13 06）\n\n### 指针运算\n\n<mark>`&`称为**取地址运算符**，用以返回变量的指针，即变量的地址。</mark>`ptr = &x;`表示将变量`x`的指针赋给`ptr`。\n\n<mark>`*`称为**指针运算符**，用以返回指针所指向的变量的值。</mark>`*`出现在声明语句中，表示声明的是指针。`*`出现在执行语句中，表示访问指针所指向的变量的值。\n\n两个指针相减表示相对位置，有时很有用。\n\n### 指针与数组\n\n在C语言中，指针与数组的关系十分密切，实际上数组名本身就是一个常量地址。对于数组`array[10]`，其数组名`array`就等效于地址`&array[0]`。可以将`array`看作一个指针，它永远指向`array[0]`。\n\n对于一个数组`a[10]`，若指针`p`指向这个数组。则`p`与`&a[0]`等价，`p+i`与`&a[i]`等价，`a[i]`与`*(p+i)`等价，`a[i]`与`p[i]`等价。\n\n设`ptr = 0x1000`，对`ptr`加`1`，若为`char* ptr`（char型数组），则`ptr`变为`0x1001`；若为`int* ptr`（int型数组），则`ptr`变为`0x1004`。*这说明，对于指针变量来说，其运算的基本单位为其指向的数据类型的变量占用的字节数。*在编写程序时，如果要使指针指向下一个数组元素，不必知道一个数组元素实际占用几个存储单元，只要简单地在指针上加`1`即可。\n\n## 时间复杂度\n\n> 算法实现所耗费的时间，即时间复杂度。\n\n（详见课本P280）一个算法花费的时间与算法中语句的执行次数成正比，即算法中语句执行次数越多，它花费的时间越多。一个<mark>算法中语句的执行次数</mark>称为**语句频度**或**时间频度**，记为$T(n)$。时间频度中的$n$称为问题的**规模**（大小）。\n\n若有某个辅助函数$F(n)$，使得当$n$​趋近于无穷大时，有\n\n$$\n\\lim_{n\\to x}\\frac{T(n)}{F(n)}=M （正常数）\n$$\n\n则称$F(n)$是$T(n)$的同数量级函数。记作$T(n)=O(F(n))$，称$O(F(n))$为算法的**时间复杂度**。\n\n按数量级增序排列，常见的时间复杂度有常数阶$O(1)$、线性阶$O(n)$、对数阶$O(\\log n)$、线性对数阶$O(n\\log n)$、平方阶$O(n^2)$、立方阶$O(n^3)$、$k$次方阶$O(n^k)$、指数阶$O(2^n)$等。对于常数阶来说，随着问题规模$n$的增大，算法中语句执行次数始终为一个常数，执行算法花费的时间不变。对于指数阶来说，随着问题规模$n$的增大，执行算法花费的时间按指数增加。\n\n冒泡排序算法和选择排序算法的时间复杂度都是$O(n^2)$，快速排序算法的（平均）时间复杂度为$O(n\\log n)$。一般来说，一个算法中，无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是$O(1)$ 。如果有一个循环，时间复杂度就为$O(n)$。如果两个循环嵌套，时间复杂度就为$O(n^2)$。\n\n```c\n//无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就是O(1)\nvoid fun(int n)\n{\n\tn += 1;\n}\n\n//根据公式有 n = 2^x，也就是 x = log2n，x即为循环代码执行次数，所以时间复杂度为O(logn)\nvoid fun(int n)\n{\n    int i = 1;\n    while (i < n)\n    {\n        i = i * 2; //i: 1 2 4 8 16 32 64 ……\n    }\n}\n\n//一般来说，只要代码里只有一个循环结构，即输入规模和执行次数呈线性相关，那这个代码的时间复杂度就是O(n)\nvoid fun(int n)\n{\n    for (int i = 0; i < n; i++)\n    {\n        n += i;\n    }\n}\n\n//可以简单理解为对数阶的程序被放入了循环结构中，也就是n*O(logn)，下面的代码的复杂度就是O(nlogn)\nvoid fun(int n)\n{\n    int j = 1;\n    for (int i = 0; i < n; i++)\n    {\n        while (i < n)\n        {\n            j = j * 2;\n        }\n    }\n}\n\n// 平方阶可以简单理解为线性阶中嵌套一个线性阶（两个循环嵌套），下面的代码复杂度就是O(n^2)\n// 立方阶同理，就是三个线性阶的嵌套，K次方阶同理\nvoid fun(int n)\n{\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; i++)\n        {\n            i = i + j;\n        }\n    }\n}\n```\n\n## 进制转换\n\nweek12第9题涉及到进制转换。\n\n```c\n/// <summary>\n/// 将字符串s（由'0'和'1'组成）从第num位开始往后8为数转化为10进制数，并返回为output。\n/// </summary>\n/// <param name=\"num\">开始位置</param>\n/// <returns>转化后的10进制数</returns>\nint Calculate(int num)\n{\n\tint output = 0;\n\n\tfor (int i = 0; i < 8; i++) //进行八次计算\n\t{\n\t\toutput += (s[num] - '0') * (int)pow(2, 7.0 - i);\n\t\tnum += 1;\n\t}\n\n\treturn output;\n}\n```\n\n将一个十进制数转化成K进制数，使用*除k取余法*。详见课本P48。\n\n```c\n/*week14第1题\n1.K进制数的转换。输入非负整数a将其转换为K进制数，2 <= K <= 32。\nK进制数使用的符号是0～9, A, ... ,V来表示（字母是大写）\n\n输入：一个十进制非负整数a和一个正整数K, 2<=K<=32。空格分隔。\n输出：K进制表示的整数。\n\n样例输入：\n1234567 22\n样例输出：\n55KGF\n*/\n\n//除K取余法\n\n#include<stdio.h>\n#include<string.h>\nint main()\n{\n\tint a;\n\tint K;\n\tchar output[100] = { 0 };\n\n\tint flag = 0;\n\n\t(void)scanf(\"%d %d\", &a, &K);\n\n\tint i = 0;\n\twhile (flag == 0)\n\t{\n\t\tif (a / K == 0)\n\t\t{\n\t\t\tif (a % K >= 0 && a % K <= 9)\n\t\t\t{\n\t\t\t\toutput[i] = a % K + '0';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar tmp = a % K - 10 + 'A';\n\t\t\t\toutput[i] = tmp;\n\t\t\t}\n\t\t\tflag = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (a % K >= 0 && a % K <= 9)\n\t\t\t{\n\t\t\t\toutput[i] = a % K + '0';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar tmp = a % K - 10 + 'A';\n\t\t\t\toutput[i] = tmp;\n\t\t\t}\n\t\t\ta /= K;\n\t\t\ti++;\n\t\t}\n\t}\n\n\tstrrev(output); //反转字符串\n\tprintf(\"%s\", output);\n\n\treturn 0;\n}\n```\n\n## 常用技巧\n\n### 将一个整数分解成各位数字\n\n下面这个算法适用于已知要分解的整数的位数。\n\n```c\nint input;\nint d, c, b, a;//a为个位数，b为十位数，c为百位数，d为千位数。\n\n(void)scanf(\"%d\", &input);\n\na = input % 10;\nb = input / 10 % 10;\nc = input / 100 % 10;\nd = input / 1000;\n//这个思想很重要。（看课本P181例5-17）\n```\n\n下面这个算法更一般。它将一个数字分解成各位后存储在一个<mark>字符串</mark>中。\n\n```c\nint input; //一个整数\nint tmp;\nchar num[10] = { 0 };\n\n(void)scanf(\"%d\", &input);\nint i = 0;\nwhile (input != 0)\n{\n\ttmp = input % 10;\n\tnum[i] = '0' + tmp; //重要！'0'+tmp是数字tmp的ASCII码。\n\t//num[0]储存的是input的个位。\n\ti++;\n\tinput /= 10;\n}\nstrrev(num); //反转字符串。\n\nfor (int j = 0; j < strlen(num); j++)\n{\n\tprintf(\"%c\\n\", num[j]); //注意以%c的格式输出\n}\n```\n\n做一些修改后，就可以把一个数字拆分为各位并储存在<mark>数组</mark>中。\n\n```c\nint input;\nint tmp;\nint num[10];\n\n(void)scanf(\"%d\", &input);\nint i = 0;\nwhile (input != 0)\n{\n\ttmp = input % 10;\n\tnum[i] = tmp;\n\t//num[0]储存的是input的个位。\n\ti++;\n\tinput /= 10;\n}\n//最后一次循环i的值为input位数+1\n\n//倒序输出\nfor (int j = i - 1; j >= 0; j--)\n{\n\tprintf(\"%d\\n\", num[j]);\n}\n```\n\n上面两段代码最后的输出结果相同。\n\n### 求一个整数的各位数字之和\n\n不需要知道这个整数的位数。\n\n```c\nint x;//开始时x为输入的值（假设有n位）。经过第k次循环后表示输入正整数的前n-k位。\nint s = 0;//s代表各位数字之和。从0开始逐渐累加。\nint d;//d表示x中的各位数字(digit)。第一次循环时d表示x的个位数,第二次循环时表示十位数，以此类推。\n\n(void)scanf(\"%d\", &x);\nwhile (x > 0)//经过一定次数的循环后x变为0，不再满足条件，循环结束。\n{\n\td = x % 10;\n\ts = s + d;\n\tx = x / 10;\n}\n```\n\n### 输出中的格式问题（如末尾的空格空行）\n\n可以考虑使用一个标签和判断结构。\n\n声明一个`flag`，如`int flag = 0;`第一次输出结果（`if(flag == 0)`）时单独设置格式，并让`flag = 1;`。设置后面输出结果的格式，并加上一个判断语句（如`else`），只有当`flag`不为0时才能进入。\n\n### 给函数添加注释\n\n在VS 2019中，可以自动生成注释。方法是在函数头前输入`///`或Ctrl+`/`。\n\n```C\n/// <summary>\n/// 通过冒泡排序算法实现对数组的排序\n/// </summary>\n/// <param name=\"s\">待排序的数组</param>\n/// <param name=\"n\">待排序的数组中的元素个数</param>\nvoid Bubble(int* s, int n)\n{\n    //\n}\n```\n\n### 确定一个整数`x`的位数\n\n位数`digi = (int)log10(x) + 1`（不要忘了`+1`）\n\n### 用string库函数计算一个字符出现的位置\n\n```C\nchar s[10] = \"apple\";\nchar chr = 'e'; //待查找的字符\nchar first = s[0]; //first为字符串的第一个字符\n//strstr返回指针，两个指针相减得到相对位置\nprintf(\"%d\", strchr(s, chr) - strchr(s, first)); //输出结果是4\n```\n\n### 字母循环\n\n一个例子week10第6题：*单词加密。输入一个字符串和一个非负整数k，对字符串中的每一个字母，*\n*用字母表中其后的第k个字母代替，<u>不够k个时再从字母a循环计数</u>。*\n例如k=3时，a用d代替，A用D代替，x用a代替，y用b代替，保持大小写不变。\n\n```c\n//只考虑需要从a再开始循环的情况\nint k;\nchar c, after; //其中c为加密前的字母，after为加密后的字母\n//要考虑k比较大的情况，字母表要循环多次，故用取余运算%\nafter = ((k - ('z' - c + 1)) % 26) + 'a';\n```\n\n### 数组的循环移动\n\nweek11第1题，注意不使用新的数组。\n\n```c\n/// <summary>\n/// 将长度为n的数组a向右循环移动m个位置。\n/// </summary>\n/// <param name=\"a\">数组</param>\n/// <param name=\"n\">数组长度</param>\n/// <param name=\"m\">移动距离</param>\nvoid move(int a[], int n, int m)\n{\n    int tmp;\n    while (m != 0) //数组循环，一次只移动一个，移动m次\n    {\n        tmp = a[n - 1]; //数组a中最后一个元素\n        for (int j = n - 1; j >= 1; j--) //一次循环只移动一个，依次移动\n        {\n            a[j] = a[j - 1];\n        }\n        a[0] = tmp; //把tmp赋值给第一个元素\n        m--;\n    }\n}\n```\n\n### 在数组中删除一个元素\n\n```c\n/// <summary>\n/// 删除数组s中num处的一个字符，其中数组长度为length\n/// </summary>\n/// <param name=\"num\">待删除元素的位置</param>\nvoid Delete(int num)\n{\n\tfor (int i = num; i <= length - 2; i++)\n\t{\n\t\ts[i] = s[i + 1];\n\t}\n\ts[length - 1] = '\\0';\n}\n```\n\n## 经典代码\n\n### 最大公因数(gcd)和最小公倍数(lcm)\n\n求两个数的最大公约数(greatest common divisor)和最小公倍数(least common multiple)。\n\n欧几里得算法又称辗转相除法，是指用于计算两个非负整数`a`，`b`的最大公约数。\n\n应用领域有数学和计算机两个方面。计算公式`gcd(a,b) = gcd(b,a % b)`。\n\n假如需要求 1997 和 615 两个正整数的最大公约数，用欧几里得算法，是这样进行的：\n$1997 / 615 = 3$ (余152)\n$615 / 152 = 4$ (余7)\n$152 / 7 = 21$ (余5)\n$7 / 5 = 1$ (余2)\n$5 / 2 = 2$ (余1)\n$2 / 1 = 2$ (余0)\n至此，最大公约数为1。\n\n以除数和余数反复做除法运算，<mark>当余数为 0 时</mark>，取当前算式除数为最大公约数。\n\n```c\n//用辗转相除法的思想\nint gcd(int x, int y)\n{\n\treturn y ? gcd(y, x % y) : x;  //除数变为被除数，余数变为除数。\n\t//y = 0 即上次递归中的 x % y = 0，即余数为零，返回x。\n\t//gcd(y, x % y)为求 y 与 x % y 的最大公约数。即求除数与余数的最大公约数。\n}\n```\n\n假设$x$和$y$的最大公约数是$m$，最小公倍数是$n$，则 $x\\times y=m\\times n$。\n\n```c\nint lcm(int x, int y)\n{\n\treturn (x * y) / gcd(x, y);\n}\n```\n\n#### 扩展\n\n求一组数的最大公约数和最小公倍数。如week11第3题。\n\n**思路**：用`gcd()`函数求出前两个数的最大公约数，用这两个数求得的这个最大公约数和后一位数求最大公约数，以此类推，最后求得一组数的最大公约数。最小公倍数可以用两个数相乘除以最大公约数来计算，这里就要用到上边的`gcd()`函数，通过循环，求得一组数的最小公倍数。\n\n```c\n/*求n个数的最大公约数。其中：2<=n<50\n输入：n个正整数，用空格隔开。以0作为输入的结束标志。\n输出：最大公约数。\n\n样例输入：\n4928 4160 6144 0\n样例输出：\n64\n*/\n\n#include<stdio.h>\nint gcd(int x, int y)\n{\n\treturn y ? gcd(y, x % y) : x;\n}\n\nint main()\n{\n\tint a[100];\n\tint tmp; //临时的最大公约数\n\tint n = 0; //输入数字的个数\n\n\t(void)scanf(\"%d\", &a[0]);\n\twhile (a[n] != 0)\n\t{\n\t\tn++;\n\t\t(void)scanf(\"%d\", &a[n]);\n\t}\n\ttmp = gcd(a[0], a[1]);\n\tfor (int i = 2; i <= n-1; i++)\n\t{\n\t\ttmp = gcd(tmp, a[i]);\n\t}\n\tprintf(\"%d\", tmp);\n\n\treturn 0;\n}\n```\n\n### 将一个整数分解为1和各个质因子的相乘\n\n从键盘输入一个正整数（>1)，然后将该整数分解为1和各个质因子的相乘，如果输入的整数本身就是质数，则应分解为1和该数本身相乘。\n\n```c\n#include<stdio.h>\nint main()\n{\n\tint n, i;\n\t(void)scanf(\"%d\", &n);\n\tprintf(\"1\");\n\tfor (i = 2; i <= n; i++) \n\t{ \n\t\t//while循环保证了如果有多个相同的质因子也能正常输出。如18=1*2*3*3。\n        while (n % i == 0)\n\t\t{ \n\t\t\tprintf(\"*%d\", i);\n\t\t\tn = n / i; \n\t\t} \n\t}\n\treturn 0;\n}\n```\n\n### 汉诺塔问题(hanoi)\n\n见课本P229。\n\n有A、B、C三根针，其中A针上摆有由小到大N个金盘，要将这些金盘由A针移动到C针。规则是在任何时候及任一根针上，小片永远在大片上面。\n\n用递归算法解决。\n\n```c\n#include<stdio.h>\n#define N 8\t//考察当金片数为N的情况。\n\n//函数move：将金片由一根针移到另一根针上。\nvoid move(char from, char to)\n{\n\tprintf(\"From %c to %c\\n\", from, to);\n}\n\n//函数hanoi：将n片金片由p1借助p2移到p3上。\nvoid hanoi(int n, char p1, char p2, char p3)\n{\n\tif (n == 1)\n\t{\n\t\tmove(p1, p3);\n\t}\n\telse\n\t{\n\t\thanoi(n - 1, p1, p3, p2);\n\t\tmove(p1, p3);\n\t\thanoi(n - 1, p2, p1, p3);\n\t}\n}\n\n//测试用主函数。\nint main()\n{\n\thanoi(N, 'A', 'B', 'C');\n\n\treturn 0;\n}\n```\n\n### 排序算法\n\n#### 冒泡排序\n\n> 冒泡排序的基本思想是两两比较待排序的关键字，发现两个记录的次序相反时即进行交换，直到没有反序的记录为止。\n\n详见课本P283。冒泡排序的时间复杂度为$O(n^2)$。<mark>从末尾</mark>开始两两比较。<mark>反序就交换。</mark>\n\n```c\n/// <summary>\n/// 通过冒泡排序算法实现对数组的排序（由小到大）\n/// </summary>\n/// <param name=\"s\">待排序的数组</param>\n/// <param name=\"n\">待排序的数组中的元素个数</param>\nvoid Bubble(int* s, int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = n - 1; j > i; j--)\n\t\t{\n\t\t\tif (s[j - 1] > s[j]) //与要排列的顺序（从小到大）相反，就交换。\n             //若要从大到小排序，只用改为<。\n\t\t\t{\n\t\t\t\t//交换\n\t\t\t\tint temp = s[j];\n\t\t\t\ts[j] = s[j - 1];\n\t\t\t\ts[j - 1] = temp;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n下面一个例子来自week13第1题，涉及结构体及字符串的冒泡排序。\n\n```c\nfor (int i = 0; i < n; i++)\n{\n\tfor (int j = n - 1; j > i; j--)\n\t{\n\t\tif (strcmp(input[j - 1].name, input[j].name) > 0)\n\t\t{\n\t\t\t//交换\n\t\t\tchar tmp_name[20] = { 0 };\n\t\t\tchar tmp_tele[20] = { 0 };\n\t\t\tstrcpy(tmp_name, input[j].name);\n\t\t\tstrcpy(tmp_tele, input[j].tele);\n\t\t\tstrcpy(input[j].name, input[j - 1].name);\n\t\t\tstrcpy(input[j].tele, input[j - 1].tele);\n\t\t\tstrcpy(input[j - 1].name, tmp_name);\n\t\t\tstrcpy(input[j - 1].tele, tmp_tele);\n\t\t}\n\t}\n}\n```\n\n#### 选择排序\n\n> 选择排序算法的思想是，第一次从数组中选择最小的元素，并将它与第一个元素交换。第二次选择剩余元素中最小的（是所有元素中第二小的），并将其与第二个元素交换。一直这样做下去……\n\n详见课本P285。选择排序的时间复杂度为$O(n^2)$。\n\n```c\n/// <summary>\n/// 通过选择排序算法实现对数组的排序（由小到大）\n/// </summary>\n/// <param name=\"s\">待排序的数组</param>\n/// <param name=\"n\">待排序的数组中的元素个数</param>\nvoid SelectionSort(int* s, int n)\n{\n\t//最小一个数的索引\n\tint smallest;\n\tfor (int i = 0; i < n-1; i++)\n\t{\n\t\tsmallest = i;\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif (s[j] < s[smallest])\n\t\t\t{\n\t\t\t\tsmallest = j;\n\t\t\t}\n\t\t}\n\t\t//交换\n\t\tint temp = s[smallest];\n\t\ts[smallest] = s[i];\n\t\ts[i] = temp;\n\t}\n}\n```\n\n#### 快速排序\n\n快速排序的基本思想是，通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另一部分的所有数据小，然后再按照此方法对这两部分数据分别进行快速排序，整个排序过程可以*递归*进行，以此达到整个数据变为有序序列。详见课本P287\n\n快速排序的平均时间复杂度为$O(n\\log n)$，最坏的情况（即待排序的数据已经有序）下退化为冒泡排序，时间复杂度为$O(n^2)$。\n\n### 查找算法\n\n#### 顺序查找\n\n详见课本P290 顺序查找的平均查找长度ASL为$(n+1)/2$，时间复杂度是$O(n)$。\n\n#### 折半查找\n\n详见课本P291 折半查找适用于很少变动而又经常需进行查找的*有序表*。折半查找的平均查找长度ASL约为$\\log(n+1)-1$，时间复杂度是$O(\\log n)$。\n\n### 同构数\n\nweek8第4题\n\n一个整数m，如果是它的平方数的尾部，则称m为**同构数**。例如，6是其平方数36的尾部，25是其平方数625的尾部，那么6和25都是同构数。\n\n在具体判断时，可采用这样的方法，对n位的整数m，取出其平方数m\\*m右边的n位进行判断，方法是用m\\*m除以10的n次方取余数。（如课本P193例5-24）（需要知道m的范围）\n\n另一种更好的方法如下所示：\n\n```C\n//寻找m到n间所有的同构数\n\n#include<stdio.h>\n#include<math.h>\n\nint main()\n{\n\tint m, n;\n\t(void)scanf(\"%d %d\", &m, &n);\n\tint firstNum = 0;\n\tfor (int i = m; i <= n; i++)\n\t{\n\t\t//求i的位数\n\t\tint digi = (int)log10(i) + 1;\n\t\t//判断i是否是同构数\n\t\tif ((i * i) % (int)pow(10, digi) == i)\n\t\t{\n\t\t\t//是否是输出的第一个数\n\t\t\tfirstNum == 0 ? printf(\"%d\", i) : printf(\" %d\", i);\n\t\t\tfirstNum++;\n\t\t}\n\t}\n}\n```\n\n### 求级数的前n项和\n\n一个例子：week8第6题\n\n编程求以下级数前n项之和：\n$$\ns=1-\\frac13+\\frac15-\\frac17+\\frac19-\\frac{1}{11}+\\frac{1}{13}-\\frac{1}{15}+\\cdots\n$$\n\n```C\ndouble s = 0.0;\ndouble i = 1.0;//这里把i设为double型是因为后面要使用pow函数，pow函数的两个变量必须为double型。\nint n;\ndouble u;//u为求和第i项的值。\n//注意：赋给型double型变量的值必须为double型，故要将1写作1.0。\n\n(void)scanf(\"%d\", &n);\nwhile (i <= n)\n{\n\tu = pow(-1.0, i + 1) * (1 / (2 * i - 1));\n\ts = s + u;\n\ti += 1;\n}\nprintf(\"%lf\", s);\n```\n\n从上面的例子中可以得到解决这类问题的一般方法：\n\n1. 声明`s = 0`（和），`i = 1`（项数），`u`（通项）\n2. 用`i`表示出`u`（通项）\n3. `s = s + u;`\n\n注意使用控制结构（如`while`）使求和在第n项停止。\n\n### 约瑟夫出圈\n\nweek14第4题\n\n```c\n/*(约瑟夫出圈 课本P220)\n4.有n个小孩围成一圈，从1顺序排号。从第一个人开始报数（1~k报数），凡报到k的人退出圈子，\n问最后留下的人原来排在第几号。\n\n输入：人数（不超过1000），以及报数的k（不超过3000），空格分隔。\n输出：最后留下的人的编号\n\n样例输入：\n234 3\n样例输出：\n230\n*/\n\n#include<stdio.h>\n\nint Josephus(int num, int chooseNum);\n\nint main()\n{\n\tint n, k;\n\t(void)scanf(\"%d%d\", &n, &k);\n\tprintf(\"%d\", Josephus(n, k));\n\treturn 0;\n}\n\nint Josephus(int num, int chooseNum)\n{\n\t//表示小孩的数组\n\tint boy[1000];\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tboy[i] = i + 1; //给小孩编号\n\t}\n\n\tint k = 1; //离开的小孩的个数\n\tint n = -1; //数组下标，下一个为0表示从第一个孩子开始数数\n\twhile (1)\n\t{\n\t\t//在圈中开始剔除\n\t\tfor (int j = 0; j < chooseNum;)\n\t\t{\n\t\t\tn = (n + 1) % num; //围成一圈（可以循环）\n\t\t\tif (boy[n] != 0)\n\t\t\t{\n\t\t\t\tj++; //如果该小孩还在圈中，则参加计数\n\t\t\t}\n\t\t} //要剔除的坐标即为n\n\t\tif (k == num)\n\t\t{\n\t\t\tbreak; //如果已经全部剔除完成，则跳出循环\n\t\t}\n\t\tboy[n] = 0; //剔除\n\t\tk++; //离开的小孩+1\n\t}\n\t// break语句跳转至此，返回胜利者编号\n\treturn boy[n];\n}\n```\n","tags":["C语言","复习"],"categories":["计算机"]}]