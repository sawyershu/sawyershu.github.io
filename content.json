{"posts":[{"title":"实变函数","text":"西安交通大学实变函数(2022 Spring)课程笔记。 说明 PDF无法在移动端正常显示，请用电脑浏览本网页。 笔记中包含许多错误和不妥之处，请谨慎使用。 PDF文件","link":"/2022/06/22/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/"},{"title":"C语言学习笔记","text":"这是我在准备大学计算机(2021 Fall)期末考试时编写的文档，主要整理总结课程中C语言部分的知识点。课本为吴宁主编的《大学计算机》。文中引用的题目为“课程作业平台”上的题目（在GitHub上有老师编写的答案)。 重要的题目下划线代表比较困难的题目。 week 8 04 05 07 09 week 9 02 06 07 08 10 week 10 02 03 05 06 10 week 11 01 03 05 10 week 12 01 04 06 09 week 13 01 04 06 07 week 14 01 04 06 08 注意事项 scanf()格式，(void)scanf(&quot;%d&quot;,&amp;a);不要忘记&quot;&quot;和&amp;（对于数组不用加&amp;） 判断用==，赋值用= for，while，if等后不用分号 字符串的比较，赋值等，不能用=，要用string库函数strcmp，strcpy等 函数要先定义(声明)后使用 注意区间的写法(x&gt;1&amp;&amp;x&lt;6) 判断一个字符c是否是大写字母(c&gt;='A' &amp;&amp; c&lt;='Z') 逻辑运算(如&amp;)是从左到右进行的，如果左边的结果已经能够决定结果了，就不会进行右边的运算 初始化字符串 char s[100] = { 0 };，在初始化数组时全部置0可以避免出现警告“可能没有为字符串添加终止符”。其他类型的数组不用初始化。 “烫烫烫”的问题：按照%s输出字符串的时候,遇到了未初始化的空间 注意初始化字符串( char s[100] = { 0 }; ) 注意在字符串末尾加上终止符'\\0' 若要对字符串元素依次赋值(数字)，要注意将 4变为'4' (加偏移 4+'0') “屯屯屯”的问题：使用动态分配时出现错误 注意在字符串末尾加上终止符'\\0' 宏定义#define 对复杂类型进行排序，建议写成结构体 用scanf即可，不要用scanf_s，使用时为(void)scanf(); 掌握冒泡排序和选择排序（会写代码） 掌握快排的思想，可能出选择题 时间充足的话，整理代码，尽量把功能写成函数（如排序算法） 函数前注意写注释（用///） 函数原型后有分号 注意文件后缀为.c不是.cpp 使用结构体时最好使用typedef，后面使用方便。例如：typedef int DateType;可用DateType代替int arr+i 与 &amp;arr[i] 意义相同*(arr+i) 与 arr[i] 意义相同 看顺序表的mooc 综合填空题的范围：顺序表，栈，队列 要去掉小数后多余的0，使用%g的格式打印 double a = 1.2;printf(&quot;%lf\\n&quot;, a); //输出：1.200000printf(&quot;%f\\n&quot;, a); //输出：1.200000printf(&quot;%g\\n&quot;, a); //输出：1.2 去掉了小数后多余的0printf(&quot;%d\\n&quot;, (int)a); //输出：1 必须先加上强制转换，才能用%d格式输出，否则会报错printf(&quot;%lf\\n&quot;, a); //输出：1.200000 这说明了强制转换只是暂时的 类型的强制转换（见课本P176）。例如：如果i的类型为int，则(double) i将i转换为double型注意：强制类型转换操作并不改变操作数本身，运算后操作数本身未改变。 求余运算%两侧应均为int型。例如：5 % 3 = 2关于取余：任何一个整数 $n$ 都可以表示成 $n=k\\times q+r$ 其中 $0\\leq|r|&lt;|q|$ 这里的 $r$ 就是 $n$ 除以 $q$ 的余数，即 r = n % q。由此可以知道负数取余的相关规律，例如：$-9=(-2)\\times 4+(-1)$则$-9$除以$4$的余数为$-1$。 printf(&quot;%d\\n&quot;, 7 % (-5)); //2printf(&quot;%d\\n&quot;, (-7) % (-5)); //-2printf(&quot;%d\\n&quot;, (-9) % 4); //-1printf(&quot;%d\\n&quot;, (-123) % 10); //-3printf(&quot;%d\\n&quot;, (-123) % (-10)); //-3 int型输出的格式控制 %d输出普通的整数 %2d是将数字按宽度为2，采用右对齐方式输出，若数据位数不到2位，则左边补空格。 %02d与%2d相似，区别是左边补0 %.2d从执行效果来看，和%02d一样 int a = 1;printf(&quot;%d\\n&quot;, a); //结果为1printf(&quot;%2d\\n&quot;, a); //结果为 1printf(&quot;%.2d\\n&quot;, a); //结果为01printf(&quot;%02d\\n&quot;, a); //结果为01 float：单精度浮点型，占用4个字节，有7位有效数字；double：双精度浮点型，占用8个字节，有15位有效数字。使用%f和%lf输出时，都默认保留6位小数。 float a = 123456789.12345;double b = 123456789.12345;printf(&quot;%f&quot;, a); //输出：123456792.000000 可以看到超过有效数字位数则不准确printf(&quot;%lf&quot;, b); //输出：123456789.123450 准确 float型及double型输出的格式控制 %f和%lf输出普通的小数 %.2f和%.2lf保留两位小数。一般地，%.mf和%.mlf表示保留m位小数。 静态变量的特点是在程序开始运行之前就为其分配了相应的存储空间，在程序的整个运行期间静态变量一直占用着这些存储空间，直到整个程序运行结束。 int func(){ static int count = 0; //静态变量count return ++count;} 静态局部变量count只能在其定义域（func）内使用，但其生存周期却与整个程序的运行期相同。主程序在离开韩顺func后count占用的存储空间并不释放，其中的内容也就不会发生改变。 字母可用数字表示（ASCII码） printf(&quot;%d\\n&quot;, 'A'); //结果是65printf(&quot;%c%c%c&quot;, 'S' - 1, 'S', 'S' + 1); //结果是RST ASCII码（见课本P367）注意记住这个顺序：……'0'(48) ~ '9' (57)…… 'A' (65) ~ 'Z' (90)…… 'a' (97) ~ 'z' (122)…… char c;(c &lt; 'A') || ('Z' &lt; c &amp;&amp; c &lt; 'a') || (c &gt; 'z') //c不是字母 代码中有循环的计数要特别注意，防止重复计数（如week8第8题） switch控制结构 int a, grade;switch (a/10) //括号中是一个整型表达式。执行switch时先计算这个表达式，将值与各case后的常量依次比较。{case 10:case 9: grade = 5; break; //不要忘记加break，跳出switch循环。不加的话会继续执行后面的case模块。case 8: grade = 4; break;//default: //如果整型表达式的值与所有case模块的进入值无一相同，则执行default模块中的语句。 grade = 1; break;} 二维数组，如int matrix[3][4]说明了一个3行4列的整型矩阵。详见课本P204。允许省略行下标，不能省略列下标。对于二维字符数组： char c[3][8] = {&quot;Apple&quot;,&quot;Orange&quot;,&quot;Pear&quot;}; //初始化数组//注意：行和列都是从0开始计数printf (&quot;%c&quot;,c[1][4]); //输出1行4列元素'g'字符scanf (&quot;%c&quot;,&amp;c[2][3]); //输入一个字符到2行3列元素中c[2][0]='B'; //把字符赋值给2行0列元素printf (&quot;%s&quot;,c[1]); //c[1]为第2行的数组名（首元素地址），输出 Orangescanf (&quot;%s&quot;,c[2]); //输入字符串到c[2]行，从c[2]行的首地址开始存放 关于月份和天数： 1月，3月，5月，7月，8月，10月，12月有31天； 4月，6月，9月，11月有30天； 2月要区分是否为闰年，闰年为29天，普通年份为28天。 闰年：四年一闰，百年不闰，四百年再闰。 普通闰年：公历年份是4的倍数，且不是100的倍数的，为闰年（如2004年、2020年等就是闰年） 世纪闰年：公历年份是整百数的，必须是400的倍数才是闰年（如1900年不是闰年，2000年是闰年） 判断是否是闰年的算法如下： if ((year % 4 == 0 &amp;&amp; year % 100 != 0) || year % 400 == 0)//为闰年的条件 { printf(&quot;%d是闰年\\n&quot;, year);}else{ printf(&quot;%d不是闰年\\n&quot;, year);} 关于字符串的输入：一般用scanf，如果字符串包含空格，需要用gets。gets函数只有一个参数，如语句gets(name);。关于字符串的输出：一般用printf(&quot;%s&quot;, name);，如果对格式没要求，可以直接用printf(name);，也可用puts(name);，需要注意puts会自动换行。 问号表达式。详见课本P169&lt;1&gt; ? &lt;2&gt; : &lt;3&gt;; 如果&lt;1&gt;的值非零，则问号表达式的值就是&lt;2&gt;的值；如果&lt;1&gt;的值为零，则问号表达式的值就是&lt;3&gt;的值。 goto表达式：C语言可在语句前面放置一个标号，一般格式为&lt;标号&gt;: &lt;语句&gt;;，例如End: return x;。加上标号的主要目的是使用goto语句。goto语句的格式为goto &lt;标号&gt;;，例如goto End;。goto语句只能在本函数模块内使用。在考试中尽量不要用goto语句，可能会扣分。 break;语句结束整个循环；continue;语句只结束本次循环，接着进入下一次是否执行循环的判断。一个例子：week13第7题 while先判断后执行；do-while先执行后判断。详见课本P183。 函数原型中以数组为参数，格式如void count(char string[], char character)。调用函数并传参时格式如count(string, character)。注意数组的写法。在声明数组形参时，int a[]与int* a是一样的。 sizeof()是一个单目操作符，不是一个函数。其作用是求出对象在计算机内存中所占用的字节数。 int a = 100;printf(&quot;%d&quot;, sizeof(a)); //结果是4 表明一个int型占四个字节int array[] = { 1, 3, 5, 7, 9 }; //可以省略数组长度//数组长度可由 sizeof(array)/sizeof(int) 得到 算法实现所耗费的时间，即时间复杂度。算法实现所消耗的存储空间，即空间复杂度。 数组（字符型数组除外）的输入要用for循环逐个输入，这就是为什么涉及数组的题目常常要先给出数组长度。 int A[100];int n = 50; //给定n的值for (int i = 0; i &lt; n; i++){ (void)scanf(&quot;%d&quot;, &amp;A[i]);} 关于for循环： for (&lt;表达式1&gt;; &lt;表达式2&gt;; &lt;表达式3&gt;){ &lt;循环体&gt;} 执行顺序： 先执行&lt;表达式1&gt; 再执行&lt;表达式2&gt;（注意：第一次循环前就会执行&lt;表达式2&gt;，只有满足条件才进入循环体） 若满足&lt;表达式2&gt;，则进入循环体，之后再执行&lt;表达式3&gt;，然后再进行&lt;表达式2&gt;的判断 若不满足&lt;表达式2&gt;，则结束循环 对于一个函数，return &lt;&gt;;后的语句不执行，函数执行结束。 质数又称素数。一个大于1的自然数，除了1和它自身外，不能被其他自然数整除，则这个数叫做质数；否则称为合数。（规定1既不是质数也不是合数） 对字符串操作时，要巧用库函数，如strcat()，比如week12第9题，在一个字符串前面补'0' 等差数列的通项公式和前$n$项和公式 $$a_n=a_1+(n-1)d\\\\S_n=na_1+\\frac{n(n-1)}{2}d=\\frac{n(a_1+a_n)}{2}$$ 等比数列的通项公式和前$n$项和公式 $$a_n=a_1q^{n-1}\\\\S_n=\\frac{a_1(1-q^n)}{1-q}=\\frac{a_1-a_nq}{1-q}$$ 通过指针访问结构体的成员要用箭头操作符-&gt;，详见课本P262 栈是一种只能在某一端进行操作的特殊线性表。先进后出。栈顶指向栈顶元素之后的空位置。栈的大小为“栈顶-栈底”stack-&gt;top - stack-&gt;bottom。若栈顶=栈底，为空栈。若栈顶=栈大小，为满栈。队列是一种只能在表的一端进行插入操作、另一端进行删除操作的特殊线性表。先进先出。队头指向存放实际队头元素的前一个位置。队列长度为“队尾-队头”queue-&gt;rear - queue-&gt;front。对于循环队列，当队尾和队头重叠时，队列为空。随着不断的出队入队，队列向“右”移动。 数据的逻辑结构：集合、线性、非线性（树、图）数据的存储结构：顺序、链式、索引、散列 常用的函数数学函数需要加上#include&lt;math.h&gt;。以下的a可以是int型，float型，double型。 开根号x=sqrt(a); 取整向下取整x=floor(a);向上取整x=ceil(a); 四舍五入x=round(a); 对数函数x=log(a)，以e为底的对数。x=log10(a)，以10为底的对数。 幂函数$x^y$可用pow(x,y)计算，其中x和y均为double型，得到的结果也是double型。 绝对值绝对值：absolute value abs(x)求整型数据x的绝对值；fabs(y)求浮点数y的绝对值。 字符串函数C提供了一组用于字符串处理的库函数。需要加上#include&lt;string.h&gt;。详见课本P208。 strcpy()字符串复制copy strcpy(char *destin, char *source);，将字符串source的内容复制到字符型数组destin中。 strlen()字符串长度length int strlen(char *s);，返回字符串s的长度，不包括字符串结束符'\\0'。如&quot;apple&quot;的长度为5。 strcmp()字符串比较compare int strcmp(char *string1, char *string2);，比较两个字符串（按照字典序，即在字典中排在前面的单词小于排在其后的单词）（比较ASCII码）。 string1小于string2，返回负整数值。 string1等于string2，返回0。 string1大于string2，返回正整数值。 strcat()连接字符串catenate strcat(char *destin, char *source);，将字符串source的内容复制到字符型数组destin中原来的字符串的后面，使两个字符串合并成一个字符串。 strrev反转字符串reverse char* strrev(char *string);反转字符串，并发挥反转后的字符串的指针。要将一个字符串反转并储存在原来的字符型数组中，可以用strcpy(string, strrev(string));。 char s[10] = &quot;apple&quot;;printf(&quot;%s\\n&quot;, strrev(s)); //结果是elppaprintf(&quot;%s\\n&quot;, s); //结果是elppa，说明了字符串s中的内容已被修改 查找字符、字符串character char* strchr(char* string, char c);其中string为被查找的字符串，c为要查找的字符。返回在字符串string中第一次出现字符c的位置（指针），如果未找到该字符c则返回NULL。 string char* strstr(char* string1, char* string2);其中string1为被查找的字符串，string2为要查找的字符串。返回在字符串string1中第一次出现字符串string2的位置（指针），如果未找到该字符串则返回NULL。 大小写字母转换lower strlwr(char *string);大写变为小写； upper strupr(char *string);小写变为大写。 动态分配函数需要加上#include&lt;stdlib.h&gt;。详见课本P258。 分配内存空间函数mallocmemory allocation 调用形式：(类型说明符*)malloc(size)。该函数在内存中分配一块长度为size字节的连续区域。“类型说明符”表示把该区域用于何种数据类型。(类型说明符*)表示把返回值强制转换为该类型的指针。该函数返回一个指针 ，指向该区域的首地址。如果分配失败，则返回NULL。如str = (char*)malloc(100);表示分配了100个字节的内存空间。 分配内存空间函数callocclear allocation 调用形式：(类型说明符*)calloc(n, size)。分配n块长度为size字节的连续区域。该函数与malloc函数的区别在与一次可以分配n块区域，另外，calloc会将分配的内存初始化为0。 释放内存空间函数free调用形式：free(ptr);。释放ptr指向的一块内存空间。ptr是一个任意类型的指针变量，它指向被释放的区域的首地址。被释放的区域应是由malloc或calloc函数分配的区域。假如p是一个指针，则该函数的用法是free(p);。 结构体 C语言中的结构体类型适用于说明具有层次结构的复杂数据。 首先，需要根据数据的具体情况定义结构体的数据类型。在定义了结构体类型后，即可用其声明该结构体的变量和数组。详见课本P210 结构体类型的定义例如，可定义一个表示日期的结构体，它有3个成员变量。 //定义结构体类型struct _date{ int year; int month; int day;}; //注意：这里有分号“;”//声明一些结构体变量struct _date yeaterday;struct _date today;struct _date tomorrow; 习惯上用typedef将struct _date重新定义为一个新的名称，这样在以后的声明中就可以简洁些。 //定义结构体类型，并将其重命名为Datetypedef struct _date{ int year; int month; int day;}Date;//声明一些结构体变量Date yesterday;Date today;Date tomorrow;//常用（将struct list重定义为List）//定义结构体List用于储存字母及出现的次数typedef struct list { char c; int count;}List; 结构体类型变量的使用对结构体类型变量的成员的引用方法为&lt;结构体类型变量名&gt;.&lt;成员变量名&gt;。 today.year = 2000;today.month = 1;today.day = 1; 和数组一样，不能将结构体变量作为一个整体输出，只能以结构体的成员作为基本变量，一次输入或输出结构体变量中的一个成员。例如： for (int i = 0; i &lt; n; i++){ (void)scanf(&quot;%s %s&quot;, &amp;input[i].name, &amp;input[i].tele);} 数组和结构体结构体的成员可以是数组，其使用方法和简单变量相同。注意，若结构体的成员为字符型数组，不用初始化为{0}。 数组也可以由结构体组成。如可以进行声明Student xjtuStudent[30];，这样，每一个数组元素都是一个结构体。 结构体的成员也可以是结构体，称为嵌套结构。嵌套结构的成员访问是很简单的，对其中每个结构成员都是从外向内引用的。 指针 C语言之所以强大以及自由，很大部分体现在其灵活的指针应用上。因此，说指针是C语言的灵魂，一点都不为过。 C语言规定： 变量的地址可以使用地址运算符&amp;求得。例如，&amp;x表示变量x的地址。 数组的地址，即数组第一个元素的地址，可以直接用数组名表示。 函数的地址用函数名表示。 某个变量的内存地址称为该变量的指针。用以表示不同指针值的变量就是指针变量，简称指针。同样的，指针变量也必须先声明。 //指针变量的声明形式&lt;数据类型&gt;* &lt;指针变量名&gt;;//下面是一些例子int* ptr; //指向int类型变量的指针（简称：int型指针）char* ptr; //指向char类型变量的指针（简称：char型指针） 由此可以知道，函数中形如int* ptr的形参实际上要求用一个形如&amp;num的指针作为实参。（week13 06） 指针运算&amp;称为取地址运算符，用以返回变量的指针，即变量的地址。ptr = &amp;x;表示将变量x的指针赋给ptr。 *称为指针运算符，用以返回指针所指向的变量的值。*出现在声明语句中，表示声明的是指针。*出现在执行语句中，表示访问指针所指向的变量的值。 两个指针相减表示相对位置，有时很有用。 指针与数组在C语言中，指针与数组的关系十分密切，实际上数组名本身就是一个常量地址。对于数组array[10]，其数组名array就等效于地址&amp;array[0]。可以将array看作一个指针，它永远指向array[0]。 对于一个数组a[10]，若指针p指向这个数组。则p与&amp;a[0]等价，p+i与&amp;a[i]等价，a[i]与*(p+i)等价，a[i]与p[i]等价。 设ptr = 0x1000，对ptr加1，若为char* ptr（char型数组），则ptr变为0x1001；若为int* ptr（int型数组），则ptr变为0x1004。这说明，对于指针变量来说，其运算的基本单位为其指向的数据类型的变量占用的字节数。在编写程序时，如果要使指针指向下一个数组元素，不必知道一个数组元素实际占用几个存储单元，只要简单地在指针上加1即可。 时间复杂度 算法实现所耗费的时间，即时间复杂度。 （详见课本P280）一个算法花费的时间与算法中语句的执行次数成正比，即算法中语句执行次数越多，它花费的时间越多。一个算法中语句的执行次数称为语句频度或时间频度，记为$T(n)$。时间频度中的$n$称为问题的规模（大小）。 若有某个辅助函数$F(n)$，使得当$n$​趋近于无穷大时，有 $$\\lim_{n\\to x}\\frac{T(n)}{F(n)}=M （正常数）$$ 则称$F(n)$是$T(n)$的同数量级函数。记作$T(n)=O(F(n))$，称$O(F(n))$为算法的时间复杂度。 按数量级增序排列，常见的时间复杂度有常数阶$O(1)$、线性阶$O(n)$、对数阶$O(\\log n)$、线性对数阶$O(n\\log n)$、平方阶$O(n^2)$、立方阶$O(n^3)$、$k$次方阶$O(n^k)$、指数阶$O(2^n)$等。对于常数阶来说，随着问题规模$n$的增大，算法中语句执行次数始终为一个常数，执行算法花费的时间不变。对于指数阶来说，随着问题规模$n$的增大，执行算法花费的时间按指数增加。 冒泡排序算法和选择排序算法的时间复杂度都是$O(n^2)$，快速排序算法的（平均）时间复杂度为$O(n\\log n)$。一般来说，一个算法中，无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是$O(1)$ 。如果有一个循环，时间复杂度就为$O(n)$。如果两个循环嵌套，时间复杂度就为$O(n^2)$。 //无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就是O(1)void fun(int n){ n += 1;}//根据公式有 n = 2^x，也就是 x = log2n，x即为循环代码执行次数，所以时间复杂度为O(logn)void fun(int n){ int i = 1; while (i &lt; n) { i = i * 2; //i: 1 2 4 8 16 32 64 …… }}//一般来说，只要代码里只有一个循环结构，即输入规模和执行次数呈线性相关，那这个代码的时间复杂度就是O(n)void fun(int n){ for (int i = 0; i &lt; n; i++) { n += i; }}//可以简单理解为对数阶的程序被放入了循环结构中，也就是n*O(logn)，下面的代码的复杂度就是O(nlogn)void fun(int n){ int j = 1; for (int i = 0; i &lt; n; i++) { while (i &lt; n) { j = j * 2; } }}// 平方阶可以简单理解为线性阶中嵌套一个线性阶（两个循环嵌套），下面的代码复杂度就是O(n^2)// 立方阶同理，就是三个线性阶的嵌套，K次方阶同理void fun(int n){ for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; i++) { i = i + j; } }} 进制转换week12第9题涉及到进制转换。 /// &lt;summary&gt;/// 将字符串s（由'0'和'1'组成）从第num位开始往后8为数转化为10进制数，并返回为output。/// &lt;/summary&gt;/// &lt;param name=&quot;num&quot;&gt;开始位置&lt;/param&gt;/// &lt;returns&gt;转化后的10进制数&lt;/returns&gt;int Calculate(int num){ int output = 0; for (int i = 0; i &lt; 8; i++) //进行八次计算 { output += (s[num] - '0') * (int)pow(2, 7.0 - i); num += 1; } return output;} 将一个十进制数转化成K进制数，使用除k取余法。详见课本P48。 /*week14第1题1.K进制数的转换。输入非负整数a将其转换为K进制数，2 &lt;= K &lt;= 32。K进制数使用的符号是0～9, A, ... ,V来表示（字母是大写）输入：一个十进制非负整数a和一个正整数K, 2&lt;=K&lt;=32。空格分隔。输出：K进制表示的整数。样例输入：1234567 22样例输出：55KGF*///除K取余法#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(){ int a; int K; char output[100] = { 0 }; int flag = 0; (void)scanf(&quot;%d %d&quot;, &amp;a, &amp;K); int i = 0; while (flag == 0) { if (a / K == 0) { if (a % K &gt;= 0 &amp;&amp; a % K &lt;= 9) { output[i] = a % K + '0'; } else { char tmp = a % K - 10 + 'A'; output[i] = tmp; } flag = 1; } else { if (a % K &gt;= 0 &amp;&amp; a % K &lt;= 9) { output[i] = a % K + '0'; } else { char tmp = a % K - 10 + 'A'; output[i] = tmp; } a /= K; i++; } } strrev(output); //反转字符串 printf(&quot;%s&quot;, output); return 0;} 常用技巧将一个整数分解成各位数字下面这个算法适用于已知要分解的整数的位数。 int input;int d, c, b, a;//a为个位数，b为十位数，c为百位数，d为千位数。(void)scanf(&quot;%d&quot;, &amp;input);a = input % 10;b = input / 10 % 10;c = input / 100 % 10;d = input / 1000;//这个思想很重要。（看课本P181例5-17） 下面这个算法更一般。它将一个数字分解成各位后存储在一个字符串中。 int input; //一个整数int tmp;char num[10] = { 0 };(void)scanf(&quot;%d&quot;, &amp;input);int i = 0;while (input != 0){ tmp = input % 10; num[i] = '0' + tmp; //重要！'0'+tmp是数字tmp的ASCII码。 //num[0]储存的是input的个位。 i++; input /= 10;}strrev(num); //反转字符串。for (int j = 0; j &lt; strlen(num); j++){ printf(&quot;%c\\n&quot;, num[j]); //注意以%c的格式输出} 做一些修改后，就可以把一个数字拆分为各位并储存在数组中。 int input;int tmp;int num[10];(void)scanf(&quot;%d&quot;, &amp;input);int i = 0;while (input != 0){ tmp = input % 10; num[i] = tmp; //num[0]储存的是input的个位。 i++; input /= 10;}//最后一次循环i的值为input位数+1//倒序输出for (int j = i - 1; j &gt;= 0; j--){ printf(&quot;%d\\n&quot;, num[j]);} 上面两段代码最后的输出结果相同。 求一个整数的各位数字之和不需要知道这个整数的位数。 int x;//开始时x为输入的值（假设有n位）。经过第k次循环后表示输入正整数的前n-k位。int s = 0;//s代表各位数字之和。从0开始逐渐累加。int d;//d表示x中的各位数字(digit)。第一次循环时d表示x的个位数,第二次循环时表示十位数，以此类推。(void)scanf(&quot;%d&quot;, &amp;x);while (x &gt; 0)//经过一定次数的循环后x变为0，不再满足条件，循环结束。{ d = x % 10; s = s + d; x = x / 10;} 输出中的格式问题（如末尾的空格空行）可以考虑使用一个标签和判断结构。 声明一个flag，如int flag = 0;第一次输出结果（if(flag == 0)）时单独设置格式，并让flag = 1;。设置后面输出结果的格式，并加上一个判断语句（如else），只有当flag不为0时才能进入。 给函数添加注释在VS 2019中，可以自动生成注释。方法是在函数头前输入///或Ctrl+/。 /// &lt;summary&gt;/// 通过冒泡排序算法实现对数组的排序/// &lt;/summary&gt;/// &lt;param name=&quot;s&quot;&gt;待排序的数组&lt;/param&gt;/// &lt;param name=&quot;n&quot;&gt;待排序的数组中的元素个数&lt;/param&gt;void Bubble(int* s, int n){ //} 确定一个整数x的位数位数digi = (int)log10(x) + 1（不要忘了+1） 用string库函数计算一个字符出现的位置char s[10] = &quot;apple&quot;;char chr = 'e'; //待查找的字符char first = s[0]; //first为字符串的第一个字符//strstr返回指针，两个指针相减得到相对位置printf(&quot;%d&quot;, strchr(s, chr) - strchr(s, first)); //输出结果是4 字母循环一个例子week10第6题：单词加密。输入一个字符串和一个非负整数k，对字符串中的每一个字母，用字母表中其后的第k个字母代替，不够k个时再从字母a循环计数。例如k=3是，a用d代替，A用D代替，x用a代替，y用b代替，保持大小写不变。 //只考虑需要从a再开始循环的情况int k;char c, after; //其中c为加密前的字母，after为加密后的字母//要考虑k比较大的情况，字母表要循环多次，故用取余运算%after = ((k - ('z' - c + 1)) % 26) + 'a'; 数组的循环移动week11第1题，注意不使用新的数组。 /// &lt;summary&gt;/// 将长度为n的数组a向右循环移动m个位置。/// &lt;/summary&gt;/// &lt;param name=&quot;a&quot;&gt;数组&lt;/param&gt;/// &lt;param name=&quot;n&quot;&gt;数组长度&lt;/param&gt;/// &lt;param name=&quot;m&quot;&gt;移动距离&lt;/param&gt;void move(int a[], int n, int m){ int tmp; while (m != 0) //数组循环，一次只移动一个，移动m次 { tmp = a[n - 1]; //数组a中最后一个元素 for (int j = n - 1; j &gt;= 1; j--) //一次循环只移动一个，依次移动 { a[j] = a[j - 1]; } a[0] = tmp; //把tmp赋值给第一个元素 m--; }} 在数组中删除一个元素/// &lt;summary&gt;/// 删除数组s中num处的一个字符，其中数组长度为length/// &lt;/summary&gt;/// &lt;param name=&quot;num&quot;&gt;待删除元素的位置&lt;/param&gt;void Delete(int num){ for (int i = num; i &lt;= length - 2; i++) { s[i] = s[i + 1]; } s[length - 1] = '\\0';} 经典代码最大公因数(gcd)和最小公倍数(lcm)求两个数的最大公约数(greatest common divisor)和最小公倍数(least common multiple)。 欧几里得算法又称辗转相除法，是指用于计算两个非负整数a，b的最大公约数。 应用领域有数学和计算机两个方面。计算公式gcd(a,b) = gcd(b,a % b)。 假如需要求 1997 和 615 两个正整数的最大公约数，用欧几里得算法，是这样进行的：$1997 / 615 = 3$ (余152)$615 / 152 = 4$ (余7)$152 / 7 = 21$ (余5)$7 / 5 = 1$ (余2)$5 / 2 = 2$ (余1)$2 / 1 = 2$ (余0)至此，最大公约数为1。 以除数和余数反复做除法运算，当余数为 0 时，取当前算式除数为最大公约数。 //用辗转相除法的思想int gcd(int x, int y){ return y ? gcd(y, x % y) : x; //除数变为被除数，余数变为除数。 //y = 0 即上次递归中的 x % y = 0，即余数为零，返回x。 //gcd(y, x % y)为求 y 与 x % y 的最大公约数。即求除数与余数的最大公约数。} 假设$x$和$y$的最大公约数是$m$，最小公倍数是$n$，则 $x\\times y=m\\times n$。 int lcm(int x, int y){ return (x * y) / gcd(x, y);} 扩展求一组数的最大公约数和最小公倍数。如week11第3题。 思路：用gcd()函数求出前两个数的最大公约数，用这两个数求得的这个最大公约数和后一位数求最大公约数，以此类推，最后求得一组数的最大公约数。最小公倍数可以用两个数相乘除以最大公约数来计算，这里就要用到上边的gcd()函数，通过循环，求得一组数的最小公倍数。 /*求n个数的最大公约数。其中：2&lt;=n&lt;50输入：n个正整数，用空格隔开。以0作为输入的结束标志。输出：最大公约数。样例输入：4928 4160 6144 0样例输出：64*/#include&lt;stdio.h&gt;int gcd(int x, int y){ return y ? gcd(y, x % y) : x;}int main(){ int a[100]; int tmp; //临时的最大公约数 int n = 0; //输入数字的个数 (void)scanf(&quot;%d&quot;, &amp;a[0]); while (a[n] != 0) { n++; (void)scanf(&quot;%d&quot;, &amp;a[n]); } tmp = gcd(a[0], a[1]); for (int i = 2; i &lt;= n-1; i++) { tmp = gcd(tmp, a[i]); } printf(&quot;%d&quot;, tmp); return 0;} 将一个整数分解为1和各个质因子的相乘从键盘输入一个正整数（&gt;1)，然后将该整数分解为1和各个质因子的相乘，如果输入的整数本身就是质数，则应分解为1和该数本身相乘。 #include&lt;stdio.h&gt;int main(){ int n, i; (void)scanf(&quot;%d&quot;, &amp;n); printf(&quot;1&quot;); for (i = 2; i &lt;= n; i++) { //while循环保证了如果有多个相同的质因子也能正常输出。如18=1*2*3*3。 while (n % i == 0) { printf(&quot;*%d&quot;, i); n = n / i; } } return 0;} 汉诺塔问题(hanoi)见课本P229。 有A、B、C三根针，其中A针上摆有由小到大N个金盘，要将这些金盘由A针移动到C针。规则是在任何时候及任一根针上，小片永远在大片上面。 用递归算法解决。 #include&lt;stdio.h&gt;#define N 8 //考察当金片数为N的情况。//函数move：将金片由一根针移到另一根针上。void move(char from, char to){ printf(&quot;From %c to %c\\n&quot;, from, to);}//函数hanoi：将n片金片由p1借助p2移到p3上。void hanoi(int n, char p1, char p2, char p3){ if (n == 1) { move(p1, p3); } else { hanoi(n - 1, p1, p3, p2); move(p1, p3); hanoi(n - 1, p2, p1, p3); }}//测试用主函数。int main(){ hanoi(N, 'A', 'B', 'C'); return 0;} 排序算法冒泡排序 冒泡排序的基本思想是两两比较待排序的关键字，发现两个记录的次序相反时即进行交换，直到没有反序的记录为止。 详见课本P283。冒泡排序的时间复杂度为$O(n^2)$。从末尾开始两两比较。反序就交换。 /// &lt;summary&gt;/// 通过冒泡排序算法实现对数组的排序（由小到大）/// &lt;/summary&gt;/// &lt;param name=&quot;s&quot;&gt;待排序的数组&lt;/param&gt;/// &lt;param name=&quot;n&quot;&gt;待排序的数组中的元素个数&lt;/param&gt;void Bubble(int* s, int n){ for (int i = 0; i &lt; n; i++) { for (int j = n - 1; j &gt; i; j--) { if (s[j - 1] &gt; s[j]) //与要排列的顺序（从小到大）相反，就交换。 //若要从大到小排序，只用改为&lt;。 { //交换 int temp = s[j]; s[j] = s[j - 1]; s[j - 1] = temp; } } }} 下面一个例子来自week13第1题，涉及结构体及字符串的冒泡排序。 for (int i = 0; i &lt; n; i++){ for (int j = n - 1; j &gt; i; j--) { if (strcmp(input[j - 1].name, input[j].name) &gt; 0) { //交换 char tmp_name[20] = { 0 }; char tmp_tele[20] = { 0 }; strcpy(tmp_name, input[j].name); strcpy(tmp_tele, input[j].tele); strcpy(input[j].name, input[j - 1].name); strcpy(input[j].tele, input[j - 1].tele); strcpy(input[j - 1].name, tmp_name); strcpy(input[j - 1].tele, tmp_tele); } }} 选择排序 选择排序算法的思想是，第一次从数组中选择最小的元素，并将它与第一个元素交换。第二次选择剩余元素中最小的（是所有元素中第二小的），并将其与第二个元素交换。一直这样做下去…… 详见课本P285。选择排序的时间复杂度为$O(n^2)$。 /// &lt;summary&gt;/// 通过选择排序算法实现对数组的排序（由小到大）/// &lt;/summary&gt;/// &lt;param name=&quot;s&quot;&gt;待排序的数组&lt;/param&gt;/// &lt;param name=&quot;n&quot;&gt;待排序的数组中的元素个数&lt;/param&gt;void SelectionSort(int* s, int n){ //最小一个数的索引 int smallest; for (int i = 0; i &lt; n-1; i++) { smallest = i; for (int j = i + 1; j &lt; n; j++) { if (s[j] &lt; s[smallest]) { smallest = j; } } //交换 int temp = s[smallest]; s[smallest] = s[i]; s[i] = temp; }} 快速排序快速排序的基本思想是，通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另一部分的所有数据小，然后再按照此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变为有序序列。详见课本P287 快速排序的平均时间复杂度为$O(n\\log n)$，最坏的情况（即待排序的数据已经有序）下退化为冒泡排序，时间复杂度为$O(n^2)$。 查找算法顺序查找详见课本P290 顺序查找的平均查找长度ASL为$(n+1)/2$，时间复杂度是$O(n)$。 折半查找详见课本P291 折半查找适用于很少变动而又经常需进行查找的有序表。折半查找的平均查找长度ASL约为$\\log(n+1)-1$，时间复杂度是$O(\\log n)$。 同构数week8第4题 一个整数m，如果是它的平方数的尾部，则称m为同构数。例如，6是其平方数36的尾部，25是其平方数625的尾部，那么6和25都是同构数。 在具体判断时，可采用这样的方法，对n位的整数m，取出其平方数m*m右边的n位进行判断，方法是用m*m除以10的n次方取余数。（如课本P193例5-24）（需要知道m的范围） 另一种更好的方法如下所示： //寻找m到n间所有的同构数#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main(){ int m, n; (void)scanf(&quot;%d %d&quot;, &amp;m, &amp;n); int firstNum = 0; for (int i = m; i &lt;= n; i++) { //求i的位数 int digi = (int)log10(i) + 1; //判断i是否是同构数 if ((i * i) % (int)pow(10, digi) == i) { //是否是输出的第一个数 firstNum == 0 ? printf(&quot;%d&quot;, i) : printf(&quot; %d&quot;, i); firstNum++; } }} 求级数的前n项和一个例子：week8第6题 编程求以下级数前n项之和：$$s=1-\\frac13+\\frac15-\\frac17+\\frac19-\\frac{1}{11}+\\frac{1}{13}-\\frac{1}{15}+\\cdots$$ double s = 0.0;double i = 1.0;//这里把i设为double型是因为后面要使用pow函数，pow函数的两个变量必须为double型。int n;double u;//u为求和第i项的值。//注意：赋给型double型变量的值必须为double型，故要将1写作1.0。(void)scanf(&quot;%d&quot;, &amp;n);while (i &lt;= n){ u = pow(-1.0, i + 1) * (1 / (2 * i - 1)); s = s + u; i += 1;}printf(&quot;%lf&quot;, s); 从上面的例子中可以得到解决这类问题的一般方法： 声明s = 0（和），i = 1（项数），u（通项） 用i表示出u（通项） s = s + u; 注意使用控制结构（如while）使求和在第n项停止。 约瑟夫出圈week14第4题 /*(约瑟夫出圈 课本P220)4.有n个小孩围成一圈，从1顺序排号。从第一个人开始报数（1~k报数），凡报到k的人退出圈子，问最后留下的人原来排在第几号。输入：人数（不超过1000），以及报数的k（不超过3000），空格分隔。输出：最后留下的人的编号样例输入：234 3样例输出：230*/#include&lt;stdio.h&gt;int Josephus(int num, int chooseNum);int main(){ int n, k; (void)scanf(&quot;%d%d&quot;, &amp;n, &amp;k); printf(&quot;%d&quot;, Josephus(n, k)); return 0;}int Josephus(int num, int chooseNum){ //表示小孩的数组 int boy[1000]; for (int i = 0; i &lt; num; i++) { boy[i] = i + 1; //给小孩编号 } int k = 1; //离开的小孩的个数 int n = -1; //数组下标，下一个为0表示从第一个孩子开始数数 while (1) { //在圈中开始剔除 for (int j = 0; j &lt; chooseNum;) { n = (n + 1) % num; //围成一圈（可以循环） if (boy[n] != 0) { j++; //如果该小孩还在圈中，则参加计数 } } //要剔除的坐标即为n if (k == num) { break; //如果已经全部剔除完成，则跳出循环 } boy[n] = 0; //剔除 k++; //离开的小孩+1 } // break语句跳转至此，返回胜利者编号 return boy[n];}","link":"/2022/02/21/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"实变函数","slug":"实变函数","link":"/tags/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/"},{"name":"复习","slug":"复习","link":"/tags/%E5%A4%8D%E4%B9%A0/"},{"name":"C语言","slug":"C语言","link":"/tags/C%E8%AF%AD%E8%A8%80/"}],"categories":[{"name":"数学","slug":"数学","link":"/categories/%E6%95%B0%E5%AD%A6/"},{"name":"计算机","slug":"计算机","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"pages":[{"title":"分类","text":"","link":"/categories/index.html"},{"title":"关于","text":"Hi! 我是舒予。 学校邮箱：shu_yu[at]stu.xjtu.edu.cn。 个人邮箱：sawyershu[at]gmail[dot]com。 GitHub LinkedIn Twitter","link":"/about/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}]}