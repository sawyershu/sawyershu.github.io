<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>C语言学习笔记 - 舒予的博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="舒予的博客"><meta name="msapplication-TileImage" content="/img/Sy.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="舒予的博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="这是我在准备大学计算机(2021 Fall)期末考试时编写的文档，主要整理总结课程中C语言部分的知识点。"><meta property="og:type" content="blog"><meta property="og:title" content="C语言学习笔记"><meta property="og:url" content="https://sawyershu.com/2022/02/21/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="舒予的博客"><meta property="og:description" content="这是我在准备大学计算机(2021 Fall)期末考试时编写的文档，主要整理总结课程中C语言部分的知识点。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://sawyershu.com/img/og_image.png"><meta property="article:published_time" content="2022-02-21T00:00:00.000Z"><meta property="article:modified_time" content="2022-09-07T03:37:43.072Z"><meta property="article:author" content="舒予"><meta property="article:tag" content="C语言"><meta property="article:tag" content="复习"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://sawyershu.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://sawyershu.com/2022/02/21/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},"headline":"C语言学习笔记","image":["https://sawyershu.com/img/og_image.png"],"datePublished":"2022-02-21T00:00:00.000Z","dateModified":"2022-09-07T03:37:43.072Z","author":{"@type":"Person","name":"舒予"},"publisher":{"@type":"Organization","name":"舒予的博客","logo":{"@type":"ImageObject","url":"https://sawyershu.com/img/Sawyer.png"}},"description":"这是我在准备大学计算机(2021 Fall)期末考试时编写的文档，主要整理总结课程中C语言部分的知识点。"}</script><link rel="canonical" href="https://sawyershu.com/2022/02/21/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="icon" href="/img/Sy.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/github.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;400;500;600;700&amp;family=Roboto+Mono:wght@300;400;500;600;700"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/Sawyer.png" alt="舒予的博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-02-21T00:00:00.000Z" title="2022/2/21 08:00:00">2022-02-21</time>发表</span><span class="level-item"><time dateTime="2022-09-07T03:37:43.072Z" title="2022/9/7 11:37:43">2022-09-07</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a></span><span class="level-item">1 小时读完 (大约9957个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">C语言学习笔记</h1><div class="content"><p>这是我在准备<strong>大学计算机</strong>(2021 Fall)期末考试时编写的文档，主要整理总结课程中<strong>C语言</strong>部分的知识点。<span id="more"></span>课本为吴宁主编的《大学计算机》。文中引用的题目为“课程作业平台”上的题目（在GitHub上有老师编写的<a target="_blank" rel="noopener" href="https://github.com/AndrewChui/CHomeWork">答案</a>)。</p>
<h2 id="重要的题目"><a href="#重要的题目" class="headerlink" title="重要的题目"></a>重要的题目</h2><p>下划线代表比较困难的题目。</p>
<ul>
<li><strong>week 8</strong> 04 05 <u>07</u> 09</li>
<li><strong>week 9</strong> 02 06 <u>07</u> 08 10</li>
<li><strong>week 10</strong> 02 <u>03</u> 05 <u>06</u> 10</li>
<li><strong>week 11</strong> 01 <u>03</u> 05 10</li>
<li><strong>week 12</strong> 01 04 06 09</li>
<li><strong>week 13</strong> 01 <u>04</u> <u>06</u> 07</li>
<li><strong>week 14</strong> 01 <u>04</u> <u>06</u> <u>08</u></li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li><code>scanf()</code>格式，<code>(void)scanf(&quot;%d&quot;,&amp;a);</code>不要忘记<code>&quot;&quot;</code>和<code>&amp;</code>（对于数组不用加<code>&amp;</code>）</li>
<li>判断用<code>==</code>，赋值用<code>=</code></li>
<li><code>for</code>，<code>while</code>，<code>if</code>等后不用分号</li>
<li>字符串的比较，<strong>赋值</strong>等，不能用<code>=</code>，要用string库函数<code>strcmp</code>，<code>strcpy</code>等</li>
<li>函数要先定义(声明)后使用</li>
<li>注意区间的写法(<code>x&gt;1&amp;&amp;x&lt;6</code>)</li>
<li>判断一个字符<code>c</code>是否是大写字母(<code>c&gt;=&#39;A&#39; &amp;&amp; c&lt;=&#39;Z&#39;</code>)</li>
<li>逻辑运算(如<code>&amp;</code>)是从左到右进行的，如果左边的结果已经能够决定结果了，就不会进行右边的运算</li>
<li><mark>初始化字符串</mark> <code>char s[100] = &#123; 0 &#125;;</code>，在初始化数组时全部置0可以避免出现警告“可能没有为字符串添加终止符”。其他类型的数组不用初始化。</li>
<li>“烫烫烫”的问题：按照<code>%s</code>输出字符串的时候,遇到了未初始化的空间<ul>
<li>注意初始化字符串( <code>char s[100] = &#123; 0 &#125;;</code> )</li>
<li>注意在字符串末尾加上终止符<code>&#39;\0&#39;</code></li>
</ul>
</li>
<li>若要对字符串元素依次赋值(数字)，要注意将 4变为<code>&#39;4&#39;</code> (加偏移 4+<code>&#39;0&#39;</code>)</li>
<li>“屯屯屯”的问题：使用动态分配时出现错误<ul>
<li>注意在字符串末尾加上终止符<code>&#39;\0&#39;</code></li>
</ul>
</li>
<li>宏定义<code>#define</code></li>
<li>对复杂类型进行排序，建议写成结构体</li>
<li>用<code>scanf</code>即可，不要用<code>scanf_s</code>，使用时为<code>(void)scanf();</code></li>
<li>掌握冒泡排序和选择排序（会写代码）<ul>
<li>掌握快排的思想，可能出选择题</li>
</ul>
</li>
<li>时间充足的话，整理代码，尽量把功能写成函数（如排序算法）<ul>
<li>函数前注意写注释（用<code>///</code>）</li>
</ul>
</li>
<li>函数原型后有分号</li>
<li>注意文件后缀为.c不是.cpp</li>
<li>使用结构体时最好使用<code>typedef</code>，后面使用方便。例如：<code>typedef int DateType;</code>可用<code>DateType</code>代替<code>int</code></li>
<li><code>arr+i</code> 与 <code>&amp;arr[i]</code> 意义相同<br><code>*(arr+i)</code> 与 <code>arr[i]</code> 意义相同</li>
<li>看顺序表的mooc</li>
<li>综合填空题的范围：顺序表，栈，队列</li>
</ol>
<hr>
<ol start="25">
<li><p>要去掉小数后多余的0，使用<code>%g</code>的格式打印</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> a = <span class="number">1.2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>, a); <span class="comment">//输出：1.200000</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, a); <span class="comment">//输出：1.200000</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%g\n&quot;</span>, a); <span class="comment">//输出：1.2 去掉了小数后多余的0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="type">int</span>)a); <span class="comment">//输出：1 必须先加上强制转换，才能用%d格式输出，否则会报错</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>, a); <span class="comment">//输出：1.200000 这说明了强制转换只是暂时的</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>类型的强制转换（见课本P176）。例如：如果<code>i</code>的类型为int，则<code>(double) i</code>将<code>i</code>转换为double型</p>
<p><em>注意：强制类型转换操作并不改变操作数本身，运算后操作数本身未改变。</em></p>
</li>
<li><p>求余运算<code>%</code>两侧应均为int型。例如：<code>5 % 3 = 2</code></p>
<p>关于取余：任何一个整数 $n$ 都可以表示成 $n&#x3D;k\times q+r$ 其中 $0\leq|r|&lt;|q|$ 这里的 $r$ 就是 $n$ 除以 $q$ 的余数，即 <code>r = n % q</code>。由此可以知道<mark>负数取余</mark>的相关规律，例如：$-9&#x3D;(-2)\times 4+(-1)$则$-9$除以$4$的余数为$-1$。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">7</span> % (<span class="number">-5</span>)); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="number">-7</span>) % (<span class="number">-5</span>)); <span class="comment">//-2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="number">-9</span>) % <span class="number">4</span>); <span class="comment">//-1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="number">-123</span>) % <span class="number">10</span>); <span class="comment">//-3</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="number">-123</span>) % (<span class="number">-10</span>)); <span class="comment">//-3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><mark>int型输出的格式控制</mark></p>
<ul>
<li><code>%d</code>输出普通的整数</li>
<li><code>%2d</code>是将数字按宽度为2，采用右对齐方式输出，若数据位数不到2位，则左边补空格。</li>
<li><code>%02d</code>与<code>%2d</code>相似，区别是左边补0</li>
<li><code>%.2d</code>从执行效果来看，和<code>%02d</code>一样</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a); <span class="comment">//结果为1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%2d\n&quot;</span>, a); <span class="comment">//结果为 1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2d\n&quot;</span>, a); <span class="comment">//结果为01</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%02d\n&quot;</span>, a); <span class="comment">//结果为01</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>float</code>：单精度浮点型，占用4个字节，有7位有效数字；<code>double</code>：双精度浮点型，占用8个字节，有15位有效数字。使用<code>%f</code>和<code>%lf</code>输出时，都默认保留6位小数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> a = <span class="number">123456789.12345</span>;</span><br><span class="line"><span class="type">double</span> b = <span class="number">123456789.12345</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, a); <span class="comment">//输出：123456792.000000 可以看到超过有效数字位数则不准确</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>, b); <span class="comment">//输出：123456789.123450 准确</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><mark>float型及double型输出的格式控制</mark></p>
<ul>
<li><code>%f</code>和<code>%lf</code>输出普通的小数</li>
<li><code>%.2f</code>和<code>%.2lf</code>保留两位小数。一般地，<code>%.mf</code>和<code>%.mlf</code>表示保留m位小数。</li>
</ul>
</li>
<li><p><strong>静态变量</strong>的特点是在程序开始运行之前就为其分配了相应的存储空间，在程序的整个运行期间静态变量一直占用着这些存储空间，直到整个程序运行结束。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">//静态变量count</span></span><br><span class="line">    <span class="keyword">return</span> ++count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态局部变量<code>count</code>只能在其定义域（<code>func</code>）内使用，但其生存周期却与整个程序的运行期相同。主程序在离开韩顺<code>func</code>后<code>count</code>占用的存储空间并不释放，<em>其中的内容也就不会发生改变</em>。</p>
</li>
<li><p>字母可用数字表示（ASCII码）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="string">&#x27;A&#x27;</span>); <span class="comment">//结果是65</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c%c%c&quot;</span>, <span class="string">&#x27;S&#x27;</span> - <span class="number">1</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;S&#x27;</span> + <span class="number">1</span>); <span class="comment">//结果是RST</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><mark>ASCII码</mark>（见课本P367）<em>注意记住这个顺序：</em></p>
<p>……<code>0</code>(48) ~ <code>9</code> (57)…… <code>&#39;A&#39;</code> (65) ~ <code>&#39;Z&#39;</code> (90)…… <code>&#39;a&#39;</code> (97) ~ <code>&#39;z&#39;</code> (122)……</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c;</span><br><span class="line">(c &lt; <span class="string">&#x27;A&#x27;</span>) || (<span class="string">&#x27;Z&#x27;</span> &lt; c &amp;&amp; c &lt; <span class="string">&#x27;a&#x27;</span>) || (c &gt; <span class="string">&#x27;z&#x27;</span>) <span class="comment">//c不是字母</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>代码中有循环的计数要特别注意，防止重复计数（如week8第8题）</p>
</li>
<li><p><code>switch</code>控制结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a, grade;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (a/<span class="number">10</span>) <span class="comment">//括号中是一个整型表达式。执行switch时先计算这个表达式，将值与各case后的常量依次比较。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">    grade = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">//不要忘记加break，跳出switch循环。不加的话会继续执行后面的case模块。</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">    grade = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">default</span>: <span class="comment">//如果整型表达式的值与所有case模块的进入值无一相同，则执行default模块中的语句。</span></span><br><span class="line">    grade = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>二维数组，如<code>int matrix[3][4]</code>说明了一个3行4列的整型矩阵。详见课本P204。允许省略行下标，不能省略列下标。</p>
<p>对于二维字符数组：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c[<span class="number">3</span>][<span class="number">8</span>] = &#123;<span class="string">&quot;Apple&quot;</span>,<span class="string">&quot;Orange&quot;</span>,<span class="string">&quot;Pear&quot;</span>&#125;; <span class="comment">//初始化数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：行和列都是从0开始计数</span></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%c&quot;</span>,c[<span class="number">1</span>][<span class="number">4</span>]); <span class="comment">//输出1行4列元素&#x27;g&#x27;字符</span></span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">&quot;%c&quot;</span>,&amp;c[<span class="number">2</span>][<span class="number">3</span>]); <span class="comment">//输入一个字符到2行3列元素中</span></span><br><span class="line">c[<span class="number">2</span>][<span class="number">0</span>]=<span class="string">&#x27;B&#x27;</span>; <span class="comment">//把字符赋值给2行0列元素</span></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;%s&quot;</span>,c[<span class="number">1</span>]); <span class="comment">//c[1]为第2行的数组名（首元素地址），输出 Orange</span></span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">&quot;%s&quot;</span>,c[<span class="number">2</span>]); <span class="comment">//输入字符串到c[2]行，从c[2]行的首地址开始存放</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>关于月份和天数：</p>
<ul>
<li>1月，3月，5月，7月，8月，10月，12月有31天；</li>
<li>4月，6月，9月，11月有30天；</li>
<li>2月要区分是否为<mark>闰年</mark>，闰年为29天，普通年份为28天。</li>
</ul>
<blockquote>
<p> 闰年：四年一闰，百年不闰，四百年再闰。</p>
<ul>
<li><p>普通闰年：公历年份<u>是4的倍数，且不是100的倍数</u>的，为闰年（如2004年、2020年等就是闰年）</p>
</li>
<li><p>世纪闰年：公历年份是整百数的，必须<u>是400的倍数</u>才是闰年（如1900年不是闰年，2000年是闰年）</p>
</li>
</ul>
</blockquote>
<p>判断是否是闰年的算法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) || year % <span class="number">400</span> == <span class="number">0</span>)<span class="comment">//为闰年的条件 </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d是闰年\n&quot;</span>, year);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d不是闰年\n&quot;</span>, year);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关于字符串的输入：一般用<code>scanf</code>，如果字符串包含空格，需要用<code>gets</code>。<code>gets</code>函数只有一个参数，如语句<code>gets(name);</code>。</p>
<p>关于字符串的输出：一般用<code>printf(&quot;%s&quot;, name);</code>，如果对格式没要求，可以直接用<code>printf(name);</code>，也可用<code>puts(name);</code>，需要注意<code>puts</code>会自动换行。</p>
</li>
<li><p><mark>问号表达式</mark>。详见课本P169</p>
<p><code>&lt;1&gt; ? &lt;2&gt; : &lt;3&gt;;</code> 如果<code>&lt;1&gt;</code>的值非零，则问号表达式的值就是<code>&lt;2&gt;</code>的值；如果<code>&lt;1&gt;</code>的值为零，则问号表达式的值就是<code>&lt;3&gt;</code>的值。</p>
</li>
<li><p><code>goto</code>表达式：C语言可在语句前面放置一个标号，一般格式为<code>&lt;标号&gt;: &lt;语句&gt;;</code>，例如<code>End: return x;</code>。加上标号的主要目的是使用<code>goto</code>语句。<code>goto</code>语句的格式为<code>goto &lt;标号&gt;;</code>，例如<code>goto End;</code>。</p>
<p><code>goto</code>语句只能在本函数模块内使用。<em>在考试中尽量不要用<code>goto</code>语句，可能会扣分。</em></p>
</li>
<li><p><code>break;</code>语句结束整个循环；<code>continue;</code>语句只结束本次循环，接着进入下一次是否执行循环的判断。</p>
<p>一个例子：<mark>week13第7题</mark></p>
</li>
<li><p><code>while</code>先判断后执行；<code>do-while</code>先执行后判断。详见课本P183。</p>
</li>
<li><p>函数原型中以数组为参数，格式如<code>void count(char string[], char character)</code>。</p>
<p>调用函数并传参时格式如<code>count(string, character)</code>。<em>注意数组的写法。</em></p>
<p>在声明数组形参时，<code>int a[]</code>与<code>int* a</code>是一样的。</p>
</li>
<li><p><code>sizeof()</code>是一个单目操作符，不是一个函数。其作用是求出对象在计算机内存中所占用的<em>字节数</em>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="keyword">sizeof</span>(a)); <span class="comment">//结果是4 表明一个int型占四个字节</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span> &#125;; <span class="comment">//可以省略数组长度</span></span><br><span class="line"><span class="comment">//数组长度可由 sizeof(array)/sizeof(int) 得到</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>算法实现所耗费的时间，即<strong>时间复杂度</strong>。算法实现所消耗的存储空间，即<strong>空间复杂度</strong>。</p>
</li>
<li><p>数组（字符型数组除外）的输入要用<code>for</code>循环逐个输入，这就是为什么涉及数组的题目常常要先给出数组长度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> A[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> n = <span class="number">50</span>; <span class="comment">//给定n的值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    (<span class="type">void</span>)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;A[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关于<code>for</code>循环：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (&lt;表达式<span class="number">1</span>&gt;; &lt;表达式<span class="number">2</span>&gt;; &lt;表达式<span class="number">3</span>&gt;)</span><br><span class="line">&#123;</span><br><span class="line">    &lt;循环体&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行顺序：</p>
<ul>
<li>先执行<code>&lt;表达式1&gt;</code></li>
<li>再执行<code>&lt;表达式2&gt;</code>（<mark>注意</mark>：第一次循环前就会执行<code>&lt;表达式2&gt;</code>，只有满足条件才进入循环体）<ul>
<li>若满足<code>&lt;表达式2&gt;</code>，则进入循环体，之后再执行<code>&lt;表达式3&gt;</code>，然后再进行<code>&lt;表达式2&gt;</code>的判断</li>
<li>若不满足<code>&lt;表达式2&gt;</code>，则结束循环</li>
</ul>
</li>
</ul>
</li>
<li><p>对于一个函数，<code>return &lt;&gt;;</code>后的语句不执行，函数执行结束。</p>
</li>
<li><p><strong>质数</strong>又称<strong>素数</strong>。一个大于1的自然数，除了1和它自身外，不能被其他自然数整除，则这个数叫做质数；否则称为合数。（规定1既不是质数也不是合数）</p>
</li>
<li><p>对字符串操作时，要<mark>巧用库函数</mark>，如<code>strcat()</code>，比如week12第9题，在一个字符串前面补<code>&#39;0&#39;</code></p>
</li>
<li><p><strong>等差数列</strong>的通项公式和前$n$项和公式</p>
<p>$$<br>a_n&#x3D;a_1+(n-1)d\\<br>S_n&#x3D;na_1+\frac{n(n-1)}{2}d&#x3D;\frac{n(a_1+a_n)}{2}<br>$$</p>
<p><strong>等比数列</strong>的通项公式和前$n$项和公式</p>
<p>$$<br>a_n&#x3D;a_1q^{n-1}\\<br>S_n&#x3D;\frac{a_1(1-q^n)}{1-q}&#x3D;\frac{a_1-a_nq}{1-q}<br>$$</p>
</li>
<li><p>通过指针访问结构体的成员要用箭头操作符<code>-&gt;</code>，详见课本P262</p>
</li>
<li><p><strong>栈</strong>是一种只能在某一端进行操作的特殊线性表。先进后出。<em>栈顶指向栈顶元素之后的空位置。</em>栈的大小为“栈顶-栈底”<code>stack-&gt;top - stack-&gt;bottom</code>。若栈顶&#x3D;栈底，为空栈。若栈顶&#x3D;栈大小，为满栈。</p>
<p><strong>队列</strong>是一种只能在表的一端进行插入操作、另一端进行删除操作的特殊线性表。先进先出。<em>队头指向存放实际队头元素的前一个位置。</em>队列长度为“队尾-队头”<code>queue-&gt;rear - queue-&gt;front</code>。对于循环队列，当队尾和队头重叠时，队列为空。随着不断的出队入队，队列向“右”移动。</p>
</li>
<li><p>数据的<strong>逻辑结构</strong>：集合、线性、非线性（树、图）</p>
<p>数据的<strong>存储结构</strong>：顺序、链式、索引、散列</p>
</li>
</ol>
<h2 id="常用的函数"><a href="#常用的函数" class="headerlink" title="常用的函数"></a>常用的函数</h2><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><p>需要加上<code>#include&lt;math.h&gt;</code>。以下的<code>a</code>可以是int型，float型，double型。</p>
<h4 id="开根号"><a href="#开根号" class="headerlink" title="开根号"></a>开根号</h4><p><code>x=sqrt(a);</code></p>
<h4 id="取整"><a href="#取整" class="headerlink" title="取整"></a>取整</h4><p>向下取整<code>x=floor(a);</code>向上取整<code>x=ceil(a);</code></p>
<h4 id="四舍五入"><a href="#四舍五入" class="headerlink" title="四舍五入"></a>四舍五入</h4><p><code>x=round(a);</code></p>
<h4 id="对数函数"><a href="#对数函数" class="headerlink" title="对数函数"></a>对数函数</h4><p><code>x=log(a)</code>，以e为底的对数。<code>x=log10(a)</code>，以10为底的对数。</p>
<h4 id="幂函数"><a href="#幂函数" class="headerlink" title="幂函数"></a>幂函数</h4><p>$x^y$可用<code>pow(x,y)</code>计算，其中<code>x</code>和<code>y</code>均为double型，得到的结果也是double型。</p>
<h4 id="绝对值"><a href="#绝对值" class="headerlink" title="绝对值"></a>绝对值</h4><p><em>绝对值：absolute value</em> <code>abs(x)</code>求整型数据<code>x</code>的绝对值；<code>fabs(y)</code>求浮点数<code>y</code>的绝对值。</p>
<h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><p>C提供了一组用于字符串处理的库函数。需要加上<code>#include&lt;string.h&gt;</code>。详见课本P208。</p>
<h4 id="strcpy-字符串复制"><a href="#strcpy-字符串复制" class="headerlink" title="strcpy()字符串复制"></a><code>strcpy()</code>字符串复制</h4><p><em>copy</em> <code>strcpy(char *destin, char *source);</code>，将字符串<code>source</code>的内容复制到字符型数组<code>destin</code>中。</p>
<h4 id="strlen-字符串长度"><a href="#strlen-字符串长度" class="headerlink" title="strlen()字符串长度"></a><code>strlen()</code>字符串长度</h4><p><em>length</em> <code>int strlen(char *s);</code>，返回字符串<code>s</code>的长度，不包括字符串结束符<code>&#39;\0&#39;</code>。如<code>&quot;apple&quot;</code>的长度为5。</p>
<h4 id="strcmp-字符串比较"><a href="#strcmp-字符串比较" class="headerlink" title="strcmp()字符串比较"></a><code>strcmp()</code>字符串比较</h4><p><em>compare</em> <code>int strcmp(char *string1, char *string2);</code>，比较两个字符串（按照字典序，即在字典中排在前面的单词<mark>小于</mark>排在其后的单词）（比较ASCII码）。</p>
<ul>
<li><code>string1</code>小于<code>string2</code>，返回<em>负整数值</em>。</li>
<li><code>string1</code>等于<code>string2</code>，返回<em>0</em>。</li>
<li><code>string1</code>大于<code>string2</code>，返回<em>正整数值</em>。</li>
</ul>
<h4 id="strcat-连接字符串"><a href="#strcat-连接字符串" class="headerlink" title="strcat()连接字符串"></a><code>strcat()</code>连接字符串</h4><p><em>catenate</em> <code>strcat(char *destin, char *source);</code>，将字符串<code>source</code>的内容复制到字符型数组<code>destin</code>中原来的字符串的后面，使两个字符串合并成一个字符串。</p>
<h4 id="strrev反转字符串"><a href="#strrev反转字符串" class="headerlink" title="strrev反转字符串"></a><code>strrev</code>反转字符串</h4><p><em>reverse</em> <code>char* strrev(char *string);</code>反转字符串，并发挥反转后的字符串的指针。要将一个字符串反转并储存在原来的字符型数组中，可以用<code>strcpy(string, strrev(string));</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">10</span>] = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strrev(s)); <span class="comment">//结果是elppa</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s); <span class="comment">//结果是elppa，说明了字符串s中的内容已被修改</span></span><br></pre></td></tr></table></figure>

<h4 id="查找字符、字符串"><a href="#查找字符、字符串" class="headerlink" title="查找字符、字符串"></a>查找字符、字符串</h4><p><em>character</em> <code>char* strchr(char* string, char c);</code>其中<code>string</code>为被查找的字符串，<code>c</code>为要查找的字符。返回在字符串<code>string</code>中第一次出现字符<code>c</code>的位置（指针），如果未找到该字符<code>c</code>则返回<code>NULL</code>。</p>
<p><em>string</em> <code>char* strstr(char* string1, char* string2);</code>其中<code>string1</code>为被查找的字符串，<code>string2</code>为要查找的字符串。返回在字符串<code>string1</code>中第一次出现字符串<code>string2</code>的位置（指针），如果未找到该字符串则返回<code>NULL</code>。</p>
<h4 id="大小写字母转换"><a href="#大小写字母转换" class="headerlink" title="大小写字母转换"></a>大小写字母转换</h4><p><em>lower</em> <code>strlwr(char *string);</code>大写变为小写；</p>
<p><em>upper</em> <code>strupr(char *string);</code>小写变为大写。</p>
<h3 id="动态分配函数"><a href="#动态分配函数" class="headerlink" title="动态分配函数"></a>动态分配函数</h3><p>需要加上<code>#include&lt;stdlib.h&gt;</code>。详见课本P258。</p>
<h4 id="分配内存空间函数malloc"><a href="#分配内存空间函数malloc" class="headerlink" title="分配内存空间函数malloc"></a>分配内存空间函数<code>malloc</code></h4><p><em>memory allocation</em> 调用形式：<code>(类型说明符*)malloc(size)</code>。该函数在内存中分配一块长度为<code>size</code>字节的连续区域。<em>“类型说明符”表示把该区域用于何种数据类型。</em><code>(类型说明符*)</code>表示把返回值强制转换为该类型的指针。该函数返回一个指针 ，指向该区域的首地址。如果分配失败，则返回<code>NULL</code>。如<code>str = (char*)malloc(100);</code>表示分配了100个字节的内存空间。</p>
<h4 id="分配内存空间函数calloc"><a href="#分配内存空间函数calloc" class="headerlink" title="分配内存空间函数calloc"></a>分配内存空间函数<code>calloc</code></h4><p><em>clear allocation</em> 调用形式：<code>(类型说明符*)calloc(n, size)</code>。分配<code>n</code>块长度为<code>size</code>字节的连续区域。该函数与<code>malloc</code>函数的区别在与一次可以分配<code>n</code>块区域，另外，<code>calloc</code>会将分配的内存初始化为0。</p>
<h4 id="释放内存空间函数free"><a href="#释放内存空间函数free" class="headerlink" title="释放内存空间函数free"></a>释放内存空间函数<code>free</code></h4><p>调用形式：<code>free(ptr);</code>。释放<code>ptr</code>指向的一块内存空间。<em><code>ptr</code>是一个任意类型的指针变量，它指向被释放的区域的首地址。</em>被释放的区域应是由<code>malloc</code>或<code>calloc</code>函数分配的区域。假如<code>p</code>是一个指针，则该函数的用法是<code>free(p);</code>。</p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><blockquote>
<p>C语言中的结构体类型适用于说明具有层次结构的复杂数据。</p>
</blockquote>
<p>首先，需要根据数据的具体情况<em>定义结构体的数据类型</em>。在定义了结构体类型后，即可用其<em>声明</em>该结构体的变量和数组。<em>详见课本P210</em></p>
<h3 id="结构体类型的定义"><a href="#结构体类型的定义" class="headerlink" title="结构体类型的定义"></a>结构体类型的定义</h3><p>例如，可定义一个表示日期的结构体，它有3个成员变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义结构体类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">&#125;; <span class="comment">//注意：这里有分号“;”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一些结构体变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">date</span> <span class="title">yeaterday</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">date</span> <span class="title">today</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">date</span> <span class="title">tomorrow</span>;</span></span><br></pre></td></tr></table></figure>

<p>习惯上用<code>typedef</code>将<code>struct _date</code>重新定义为一个新的名称，这样在以后的声明中就可以<em>简洁些</em>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义结构体类型，并将其重命名为Date</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">&#125;Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一些结构体变量</span></span><br><span class="line">Date yesterday;</span><br><span class="line">Date today;</span><br><span class="line">Date tomorrow;</span><br><span class="line"></span><br><span class="line"><span class="comment">//常用（将struct list重定义为List）</span></span><br><span class="line"><span class="comment">//定义结构体List用于储存字母及出现的次数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">&#125;List;</span><br></pre></td></tr></table></figure>

<h3 id="结构体类型变量的使用"><a href="#结构体类型变量的使用" class="headerlink" title="结构体类型变量的使用"></a>结构体类型变量的使用</h3><p>对结构体类型变量的成员的引用方法为<code>&lt;结构体类型变量名&gt;.&lt;成员变量名&gt;</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">today.year = <span class="number">2002</span>;</span><br><span class="line">today.month = <span class="number">5</span>;</span><br><span class="line">today.day = <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>和数组一样，不能将结构体变量作为一个整体输出，只能以结构体的成员作为基本变量，一次输入或输出结构体变量中的一个成员。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    (<span class="type">void</span>)<span class="built_in">scanf</span>(<span class="string">&quot;%s %s&quot;</span>, &amp;input[i].name, &amp;input[i].tele);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组和结构体"><a href="#数组和结构体" class="headerlink" title="数组和结构体"></a>数组和结构体</h3><p><em>结构体的成员可以是数组</em>，其使用方法和简单变量相同。注意，若结构体的成员为字符型数组，不用初始化为<code>&#123;0&#125;</code>。</p>
<p><em>数组也可以由结构体组成</em>。如可以进行声明<code>Student xjtuStudent[30];</code>，这样，每一个数组元素都是一个结构体。</p>
<p><em>结构体的成员也可以是结构体</em>，称为嵌套结构。嵌套结构的成员访问是很简单的，对其中每个结构成员都是从外向内引用的。</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><blockquote>
<p>C语言之所以强大以及自由，很大部分体现在其灵活的指针应用上。因此，说指针是C语言的灵魂，一点都不为过。</p>
</blockquote>
<p>C语言规定：</p>
<ul>
<li>变量的地址可以使用地址运算符<code>&amp;</code>求得。例如，<code>&amp;x</code>表示变量<code>x</code>的地址。</li>
<li>数组的地址，即数组第一个元素的地址，可以直接用数组名表示。</li>
<li>函数的地址用函数名表示。</li>
</ul>
<p><mark>某个变量的内存地址称为该变量的<strong>指针</strong>。</mark>用以表示不同指针值的变量就是<strong>指针变量</strong>，简称<strong>指针</strong>。同样的，指针变量也必须先声明。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指针变量的声明形式</span></span><br><span class="line">&lt;数据类型&gt;* &lt;指针变量名&gt;;</span><br><span class="line"><span class="comment">//下面是一些例子</span></span><br><span class="line"><span class="type">int</span>* ptr; <span class="comment">//指向int类型变量的指针（简称：int型指针）</span></span><br><span class="line"><span class="type">char</span>* ptr; <span class="comment">//指向char类型变量的指针（简称：char型指针）</span></span><br></pre></td></tr></table></figure>

<p>由此可以知道，函数中形如<code>int* ptr</code>的形参实际上要求用一个形如<code>&amp;num</code>的指针作为实参。（week13 06）</p>
<h3 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h3><p><mark><code>&amp;</code>称为<strong>取地址运算符</strong>，用以返回变量的指针，即变量的地址。</mark><code>ptr = &amp;x;</code>表示将变量<code>x</code>的指针赋给<code>ptr</code>。</p>
<p><mark><code>*</code>称为<strong>指针运算符</strong>，用以返回指针所指向的变量的值。</mark><code>*</code>出现在声明语句中，表示声明的是指针。<code>*</code>出现在执行语句中，表示访问指针所指向的变量的值。</p>
<p>两个指针相减表示相对位置，有时很有用。</p>
<h3 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h3><p>在C语言中，指针与数组的关系十分密切，实际上数组名本身就是一个常量地址。对于数组<code>array[10]</code>，其数组名<code>array</code>就等效于地址<code>&amp;array[0]</code>。可以将<code>array</code>看作一个指针，它永远指向<code>array[0]</code>。</p>
<p>对于一个数组<code>a[10]</code>，若指针<code>p</code>指向这个数组。则<code>p</code>与<code>&amp;a[0]</code>等价，<code>p+i</code>与<code>&amp;a[i]</code>等价，<code>a[i]</code>与<code>*(p+i)</code>等价，<code>a[i]</code>与<code>p[i]</code>等价。</p>
<p>设<code>ptr = 0x1000</code>，对<code>ptr</code>加<code>1</code>，若为<code>char* ptr</code>（char型数组），则<code>ptr</code>变为<code>0x1001</code>；若为<code>int* ptr</code>（int型数组），则<code>ptr</code>变为<code>0x1004</code>。<em>这说明，对于指针变量来说，其运算的基本单位为其指向的数据类型的变量占用的字节数。</em>在编写程序时，如果要使指针指向下一个数组元素，不必知道一个数组元素实际占用几个存储单元，只要简单地在指针上加<code>1</code>即可。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><blockquote>
<p>算法实现所耗费的时间，即时间复杂度。</p>
</blockquote>
<p>（详见课本P280）一个算法花费的时间与算法中语句的执行次数成正比，即算法中语句执行次数越多，它花费的时间越多。一个<mark>算法中语句的执行次数</mark>称为<strong>语句频度</strong>或<strong>时间频度</strong>，记为$T(n)$。时间频度中的$n$称为问题的<strong>规模</strong>（大小）。</p>
<p>若有某个辅助函数$F(n)$，使得当$n$​趋近于无穷大时，有</p>
<p>$$<br>\lim_{n\to x}\frac{T(n)}{F(n)}&#x3D;M （正常数）<br>$$</p>
<p>则称$F(n)$是$T(n)$的同数量级函数。记作$T(n)&#x3D;O(F(n))$，称$O(F(n))$为算法的<strong>时间复杂度</strong>。</p>
<p>按数量级增序排列，常见的时间复杂度有常数阶$O(1)$、线性阶$O(n)$、对数阶$O(\log n)$、线性对数阶$O(n\log n)$、平方阶$O(n^2)$、立方阶$O(n^3)$、$k$次方阶$O(n^k)$、指数阶$O(2^n)$等。对于常数阶来说，随着问题规模$n$的增大，算法中语句执行次数始终为一个常数，执行算法花费的时间不变。对于指数阶来说，随着问题规模$n$的增大，执行算法花费的时间按指数增加。</p>
<p>冒泡排序算法和选择排序算法的时间复杂度都是$O(n^2)$，快速排序算法的（平均）时间复杂度为$O(n\log n)$。一般来说，一个算法中，无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是$O(1)$ 。如果有一个循环，时间复杂度就为$O(n)$。如果两个循环嵌套，时间复杂度就为$O(n^2)$。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就是O(1)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    n += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据公式有 n = 2^x，也就是 x = log2n，x即为循环代码执行次数，所以时间复杂度为O(logn)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        i = i * <span class="number">2</span>; <span class="comment">//i: 1 2 4 8 16 32 64 ……</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一般来说，只要代码里只有一个循环结构，即输入规模和执行次数呈线性相关，那这个代码的时间复杂度就是O(n)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        n += i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以简单理解为对数阶的程序被放入了循环结构中，也就是n*O(logn)，下面的代码的复杂度就是O(nlogn)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            j = j * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平方阶可以简单理解为线性阶中嵌套一个线性阶（两个循环嵌套），下面的代码复杂度就是O(n^2)</span></span><br><span class="line"><span class="comment">// 立方阶同理，就是三个线性阶的嵌套，K次方阶同理</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            i = i + j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p>week12第9题涉及到进制转换。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 将字符串s（由&#x27;0&#x27;和&#x27;1&#x27;组成）从第num位开始往后8为数转化为10进制数，并返回为output。</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;num&quot;&gt;开始位置&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;转化后的10进制数&lt;/returns&gt;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Calculate</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> output = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) <span class="comment">//进行八次计算</span></span><br><span class="line">    &#123;</span><br><span class="line">        output += (s[num] - <span class="string">&#x27;0&#x27;</span>) * (<span class="type">int</span>)<span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">7.0</span> - i);</span><br><span class="line">        num += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将一个十进制数转化成K进制数，使用<em>除k取余法</em>。详见课本P48。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*week14第1题</span></span><br><span class="line"><span class="comment">1.K进制数的转换。输入非负整数a将其转换为K进制数，2 &lt;= K &lt;= 32。</span></span><br><span class="line"><span class="comment">K进制数使用的符号是0～9, A, ... ,V来表示（字母是大写）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：一个十进制非负整数a和一个正整数K, 2&lt;=K&lt;=32。空格分隔。</span></span><br><span class="line"><span class="comment">输出：K进制表示的整数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">样例输入：</span></span><br><span class="line"><span class="comment">1234567 22</span></span><br><span class="line"><span class="comment">样例输出：</span></span><br><span class="line"><span class="comment">55KGF</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//除K取余法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> K;</span><br><span class="line">    <span class="type">char</span> output[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    (<span class="type">void</span>)<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;K);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (flag == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a / K == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a % K &gt;= <span class="number">0</span> &amp;&amp; a % K &lt;= <span class="number">9</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                output[i] = a % K + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">char</span> tmp = a % K - <span class="number">10</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">                output[i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a % K &gt;= <span class="number">0</span> &amp;&amp; a % K &lt;= <span class="number">9</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                output[i] = a % K + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">char</span> tmp = a % K - <span class="number">10</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">                output[i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            a /= K;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    strrev(output); <span class="comment">//反转字符串</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, output);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h2><h3 id="将一个整数分解成各位数字"><a href="#将一个整数分解成各位数字" class="headerlink" title="将一个整数分解成各位数字"></a>将一个整数分解成各位数字</h3><p>下面这个算法适用于已知要分解的整数的位数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> input;</span><br><span class="line"><span class="type">int</span> d, c, b, a;<span class="comment">//a为个位数，b为十位数，c为百位数，d为千位数。</span></span><br><span class="line"></span><br><span class="line">(<span class="type">void</span>)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line"></span><br><span class="line">a = input % <span class="number">10</span>;</span><br><span class="line">b = input / <span class="number">10</span> % <span class="number">10</span>;</span><br><span class="line">c = input / <span class="number">100</span> % <span class="number">10</span>;</span><br><span class="line">d = input / <span class="number">1000</span>;</span><br><span class="line"><span class="comment">//这个思想很重要。（看课本P181例5-17）</span></span><br></pre></td></tr></table></figure>

<p>下面这个算法更一般。它将一个数字分解成各位后存储在一个<mark>字符串</mark>中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> input; <span class="comment">//一个整数</span></span><br><span class="line"><span class="type">int</span> tmp;</span><br><span class="line"><span class="type">char</span> num[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">(<span class="type">void</span>)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (input != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    tmp = input % <span class="number">10</span>;</span><br><span class="line">    num[i] = <span class="string">&#x27;0&#x27;</span> + tmp; <span class="comment">//重要！&#x27;0&#x27;+tmp是数字tmp的ASCII码。</span></span><br><span class="line">    <span class="comment">//num[0]储存的是input的个位。</span></span><br><span class="line">    i++;</span><br><span class="line">    input /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">strrev(num); <span class="comment">//反转字符串。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">strlen</span>(num); j++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, num[j]); <span class="comment">//注意以%c的格式输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做一些修改后，就可以把一个数字拆分为各位并储存在<mark>数组</mark>中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> input;</span><br><span class="line"><span class="type">int</span> tmp;</span><br><span class="line"><span class="type">int</span> num[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">(<span class="type">void</span>)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (input != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    tmp = input % <span class="number">10</span>;</span><br><span class="line">    num[i] = tmp;</span><br><span class="line">    <span class="comment">//num[0]储存的是input的个位。</span></span><br><span class="line">    i++;</span><br><span class="line">    input /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后一次循环i的值为input位数+1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//倒序输出</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, num[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面两段代码最后的输出结果相同。</p>
<h3 id="求一个整数的各位数字之和"><a href="#求一个整数的各位数字之和" class="headerlink" title="求一个整数的各位数字之和"></a>求一个整数的各位数字之和</h3><p>不需要知道这个整数的位数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x;<span class="comment">//开始时x为输入的值（假设有n位）。经过第k次循环后表示输入正整数的前n-k位。</span></span><br><span class="line"><span class="type">int</span> s = <span class="number">0</span>;<span class="comment">//s代表各位数字之和。从0开始逐渐累加。</span></span><br><span class="line"><span class="type">int</span> d;<span class="comment">//d表示x中的各位数字(digit)。第一次循环时d表示x的个位数,第二次循环时表示十位数，以此类推。</span></span><br><span class="line"></span><br><span class="line">(<span class="type">void</span>)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"><span class="keyword">while</span> (x &gt; <span class="number">0</span>)<span class="comment">//经过一定次数的循环后x变为0，不再满足条件，循环结束。</span></span><br><span class="line">&#123;</span><br><span class="line">    d = x % <span class="number">10</span>;</span><br><span class="line">    s = s + d;</span><br><span class="line">    x = x / <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出中的格式问题（如末尾的空格空行）"><a href="#输出中的格式问题（如末尾的空格空行）" class="headerlink" title="输出中的格式问题（如末尾的空格空行）"></a>输出中的格式问题（如末尾的空格空行）</h3><p>可以考虑使用一个标签和判断结构。</p>
<p>声明一个<code>flag</code>，如<code>int flag = 0;</code>第一次输出结果（<code>if(flag == 0)</code>）时单独设置格式，并让<code>flag = 1;</code>。设置后面输出结果的格式，并加上一个判断语句（如<code>else</code>），只有当<code>flag</code>不为0时才能进入。</p>
<h3 id="给函数添加注释"><a href="#给函数添加注释" class="headerlink" title="给函数添加注释"></a>给函数添加注释</h3><p>在VS 2019中，可以自动生成注释。方法是在函数头前输入<code>///</code>或Ctrl+<code>/</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 通过冒泡排序算法实现对数组的排序</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;s&quot;&gt;待排序的数组&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;n&quot;&gt;待排序的数组中的元素个数&lt;/param&gt;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Bubble</span><span class="params">(<span class="type">int</span>* s, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="确定一个整数x的位数"><a href="#确定一个整数x的位数" class="headerlink" title="确定一个整数x的位数"></a>确定一个整数<code>x</code>的位数</h3><p>位数<code>digi = (int)log10(x) + 1</code>（不要忘了<code>+1</code>）</p>
<h3 id="用string库函数计算一个字符出现的位置"><a href="#用string库函数计算一个字符出现的位置" class="headerlink" title="用string库函数计算一个字符出现的位置"></a>用string库函数计算一个字符出现的位置</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">10</span>] = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line"><span class="type">char</span> chr = <span class="string">&#x27;e&#x27;</span>; <span class="comment">//待查找的字符</span></span><br><span class="line"><span class="type">char</span> first = s[<span class="number">0</span>]; <span class="comment">//first为字符串的第一个字符</span></span><br><span class="line"><span class="comment">//strstr返回指针，两个指针相减得到相对位置</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">strchr</span>(s, chr) - <span class="built_in">strchr</span>(s, first)); <span class="comment">//输出结果是4</span></span><br></pre></td></tr></table></figure>

<h3 id="字母循环"><a href="#字母循环" class="headerlink" title="字母循环"></a>字母循环</h3><p>一个例子week10第6题：<em>单词加密。输入一个字符串和一个非负整数k，对字符串中的每一个字母，</em><br><em>用字母表中其后的第k个字母代替，<u>不够k个时再从字母a循环计数</u>。</em><br>例如k&#x3D;3是，a用d代替，A用D代替，x用a代替，y用b代替，保持大小写不变。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只考虑需要从a再开始循环的情况</span></span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="type">char</span> c, after; <span class="comment">//其中c为加密前的字母，after为加密后的字母</span></span><br><span class="line"><span class="comment">//要考虑k比较大的情况，字母表要循环多次，故用取余运算%</span></span><br><span class="line">after = ((k - (<span class="string">&#x27;z&#x27;</span> - c + <span class="number">1</span>)) % <span class="number">26</span>) + <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="数组的循环移动"><a href="#数组的循环移动" class="headerlink" title="数组的循环移动"></a>数组的循环移动</h3><p>week11第1题，注意不使用新的数组。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 将长度为n的数组a向右循环移动m个位置。</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;a&quot;&gt;数组&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;n&quot;&gt;数组长度&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;m&quot;&gt;移动距离&lt;/param&gt;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">move</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n, <span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    <span class="keyword">while</span> (m != <span class="number">0</span>) <span class="comment">//数组循环，一次只移动一个，移动m次</span></span><br><span class="line">    &#123;</span><br><span class="line">        tmp = a[n - <span class="number">1</span>]; <span class="comment">//数组a中最后一个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">1</span>; j--) <span class="comment">//一次循环只移动一个，依次移动</span></span><br><span class="line">        &#123;</span><br><span class="line">            a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        a[<span class="number">0</span>] = tmp; <span class="comment">//把tmp赋值给第一个元素</span></span><br><span class="line">        m--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在数组中删除一个元素"><a href="#在数组中删除一个元素" class="headerlink" title="在数组中删除一个元素"></a>在数组中删除一个元素</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 删除数组s中num处的一个字符，其中数组长度为length</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;num&quot;&gt;待删除元素的位置&lt;/param&gt;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delete</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = num; i &lt;= length - <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s[i] = s[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    s[length - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="经典代码"><a href="#经典代码" class="headerlink" title="经典代码"></a>经典代码</h2><h3 id="最大公因数-gcd-和最小公倍数-lcm"><a href="#最大公因数-gcd-和最小公倍数-lcm" class="headerlink" title="最大公因数(gcd)和最小公倍数(lcm)"></a>最大公因数(gcd)和最小公倍数(lcm)</h3><p>求两个数的最大公约数(greatest common divisor)和最小公倍数(least common multiple)。</p>
<p>欧几里得算法又称辗转相除法，是指用于计算两个非负整数<code>a</code>，<code>b</code>的最大公约数。</p>
<p>应用领域有数学和计算机两个方面。计算公式<code>gcd(a,b) = gcd(b,a % b)</code>。</p>
<p>假如需要求 1997 和 615 两个正整数的最大公约数，用欧几里得算法，是这样进行的：<br>$1997 &#x2F; 615 &#x3D; 3$ (余152)<br>$615 &#x2F; 152 &#x3D; 4$ (余7)<br>$152 &#x2F; 7 &#x3D; 21$ (余5)<br>$7 &#x2F; 5 &#x3D; 1$ (余2)<br>$5 &#x2F; 2 &#x3D; 2$ (余1)<br>$2 &#x2F; 1 &#x3D; 2$ (余0)<br>至此，最大公约数为1。</p>
<p>以除数和余数反复做除法运算，<mark>当余数为 0 时</mark>，取当前算式除数为最大公约数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用辗转相除法的思想</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> y ? gcd(y, x % y) : x;  <span class="comment">//除数变为被除数，余数变为除数。</span></span><br><span class="line">    <span class="comment">//y = 0 即上次递归中的 x % y = 0，即余数为零，返回x。</span></span><br><span class="line">    <span class="comment">//gcd(y, x % y)为求 y 与 x % y 的最大公约数。即求除数与余数的最大公约数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设$x$和$y$的最大公约数是$m$，最小公倍数是$n$，则 $x\times y&#x3D;m\times n$。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lcm</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (x * y) / gcd(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>求一组数的最大公约数和最小公倍数。如week11第3题。</p>
<p><strong>思路</strong>：用<code>gcd()</code>函数求出前两个数的最大公约数，用这两个数求得的这个最大公约数和后一位数求最大公约数，以此类推，最后求得一组数的最大公约数。最小公倍数可以用两个数相乘除以最大公约数来计算，这里就要用到上边的<code>gcd()</code>函数，通过循环，求得一组数的最小公倍数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*求n个数的最大公约数。其中：2&lt;=n&lt;50</span></span><br><span class="line"><span class="comment">输入：n个正整数，用空格隔开。以0作为输入的结束标志。</span></span><br><span class="line"><span class="comment">输出：最大公约数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">样例输入：</span></span><br><span class="line"><span class="comment">4928 4160 6144 0</span></span><br><span class="line"><span class="comment">样例输出：</span></span><br><span class="line"><span class="comment">64</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> y ? gcd(y, x % y) : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> tmp; <span class="comment">//临时的最大公约数</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>; <span class="comment">//输入数字的个数</span></span><br><span class="line"></span><br><span class="line">    (<span class="type">void</span>)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">while</span> (a[n] != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        n++;</span><br><span class="line">        (<span class="type">void</span>)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = gcd(a[<span class="number">0</span>], a[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = gcd(tmp, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, tmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将一个整数分解为1和各个质因子的相乘"><a href="#将一个整数分解为1和各个质因子的相乘" class="headerlink" title="将一个整数分解为1和各个质因子的相乘"></a>将一个整数分解为1和各个质因子的相乘</h3><p>从键盘输入一个正整数（&gt;1)，然后将该整数分解为1和各个质因子的相乘，如果输入的整数本身就是质数，则应分解为1和该数本身相乘。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, i;</span><br><span class="line">    (<span class="type">void</span>)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">//while循环保证了如果有多个相同的质因子也能正常输出。如18=1*2*3*3。</span></span><br><span class="line">        <span class="keyword">while</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123; </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;*%d&quot;</span>, i);</span><br><span class="line">            n = n / i; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="汉诺塔问题-hanoi"><a href="#汉诺塔问题-hanoi" class="headerlink" title="汉诺塔问题(hanoi)"></a>汉诺塔问题(hanoi)</h3><p>见课本P229。</p>
<p>有A、B、C三根针，其中A针上摆有由小到大N个金盘，要将这些金盘由A针移动到C针。规则是在任何时候及任一根针上，小片永远在大片上面。</p>
<p>用递归算法解决。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 8    <span class="comment">//考察当金片数为N的情况。</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数move：将金片由一根针移到另一根针上。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">move</span><span class="params">(<span class="type">char</span> from, <span class="type">char</span> to)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;From %c to %c\n&quot;</span>, from, to);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数hanoi：将n片金片由p1借助p2移到p3上。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hanoi</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> p1, <span class="type">char</span> p2, <span class="type">char</span> p3)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        move(p1, p3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        hanoi(n - <span class="number">1</span>, p1, p3, p2);</span><br><span class="line">        move(p1, p3);</span><br><span class="line">        hanoi(n - <span class="number">1</span>, p2, p1, p3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试用主函数。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    hanoi(N, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><blockquote>
<p>冒泡排序的基本思想是两两比较待排序的关键字，发现两个记录的次序相反时即进行交换，直到没有反序的记录为止。</p>
</blockquote>
<p>详见课本P283。冒泡排序的时间复杂度为$O(n^2)$。<mark>从末尾</mark>开始两两比较。<mark>反序就交换。</mark></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 通过冒泡排序算法实现对数组的排序（由小到大）</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;s&quot;&gt;待排序的数组&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;n&quot;&gt;待排序的数组中的元素个数&lt;/param&gt;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Bubble</span><span class="params">(<span class="type">int</span>* s, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt; i; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j - <span class="number">1</span>] &gt; s[j]) <span class="comment">//与要排列的顺序（从小到大）相反，就交换。</span></span><br><span class="line">             <span class="comment">//若要从大到小排序，只用改为&lt;。</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//交换</span></span><br><span class="line">                <span class="type">int</span> temp = s[j];</span><br><span class="line">                s[j] = s[j - <span class="number">1</span>];</span><br><span class="line">                s[j - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面一个例子来自week13第1题，涉及结构体及字符串的冒泡排序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt; i; j--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input[j - <span class="number">1</span>].name, input[j].name) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            <span class="type">char</span> tmp_name[<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">            <span class="type">char</span> tmp_tele[<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">            <span class="built_in">strcpy</span>(tmp_name, input[j].name);</span><br><span class="line">            <span class="built_in">strcpy</span>(tmp_tele, input[j].tele);</span><br><span class="line">            <span class="built_in">strcpy</span>(input[j].name, input[j - <span class="number">1</span>].name);</span><br><span class="line">            <span class="built_in">strcpy</span>(input[j].tele, input[j - <span class="number">1</span>].tele);</span><br><span class="line">            <span class="built_in">strcpy</span>(input[j - <span class="number">1</span>].name, tmp_name);</span><br><span class="line">            <span class="built_in">strcpy</span>(input[j - <span class="number">1</span>].tele, tmp_tele);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><blockquote>
<p>选择排序算法的思想是，第一次从数组中选择最小的元素，并将它与第一个元素交换。第二次选择剩余元素中最小的（是所有元素中第二小的），并将其与第二个元素交换。一直这样做下去……</p>
</blockquote>
<p>详见课本P285。选择排序的时间复杂度为$O(n^2)$。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 通过选择排序算法实现对数组的排序（由小到大）</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;s&quot;&gt;待排序的数组&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;n&quot;&gt;待排序的数组中的元素个数&lt;/param&gt;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectionSort</span><span class="params">(<span class="type">int</span>* s, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//最小一个数的索引</span></span><br><span class="line">    <span class="type">int</span> smallest;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        smallest = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j] &lt; s[smallest])</span><br><span class="line">            &#123;</span><br><span class="line">                smallest = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换</span></span><br><span class="line">        <span class="type">int</span> temp = s[smallest];</span><br><span class="line">        s[smallest] = s[i];</span><br><span class="line">        s[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>快速排序的基本思想是，通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另一部分的所有数据小，然后再按照此方法对这两部分数据分别进行快速排序，整个排序过程可以<em>递归</em>进行，以此达到整个数据变为有序序列。详见课本P287</p>
<p>快速排序的平均时间复杂度为$O(n\log n)$，最坏的情况（即待排序的数据已经有序）下退化为冒泡排序，时间复杂度为$O(n^2)$。</p>
<h3 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h3><h4 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h4><p>详见课本P290 顺序查找的平均查找长度ASL为$(n+1)&#x2F;2$，时间复杂度是$O(n)$。</p>
<h4 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h4><p>详见课本P291 折半查找适用于很少变动而又经常需进行查找的<em>有序表</em>。折半查找的平均查找长度ASL约为$\log(n+1)-1$，时间复杂度是$O(\log n)$。</p>
<h3 id="同构数"><a href="#同构数" class="headerlink" title="同构数"></a>同构数</h3><p>week8第4题</p>
<p>一个整数m，如果是它的平方数的尾部，则称m为<strong>同构数</strong>。例如，6是其平方数36的尾部，25是其平方数625的尾部，那么6和25都是同构数。</p>
<p>在具体判断时，可采用这样的方法，对n位的整数m，取出其平方数m*m右边的n位进行判断，方法是用m*m除以10的n次方取余数。（如课本P193例5-24）（需要知道m的范围）</p>
<p>另一种更好的方法如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//寻找m到n间所有的同构数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    (<span class="type">void</span>)<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">    <span class="type">int</span> firstNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = m; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//求i的位数</span></span><br><span class="line">        <span class="type">int</span> digi = (<span class="type">int</span>)<span class="built_in">log10</span>(i) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//判断i是否是同构数</span></span><br><span class="line">        <span class="keyword">if</span> ((i * i) % (<span class="type">int</span>)<span class="built_in">pow</span>(<span class="number">10</span>, digi) == i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//是否是输出的第一个数</span></span><br><span class="line">            firstNum == <span class="number">0</span> ? <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i) : <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, i);</span><br><span class="line">            firstNum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求级数的前n项和"><a href="#求级数的前n项和" class="headerlink" title="求级数的前n项和"></a>求级数的前n项和</h3><p>一个例子：week8第6题</p>
<p>编程求以下级数前n项之和：<br>$$<br>s&#x3D;1-\frac13+\frac15-\frac17+\frac19-\frac{1}{11}+\frac{1}{13}-\frac{1}{15}+\cdots<br>$$</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> s = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">double</span> i = <span class="number">1.0</span>;<span class="comment">//这里把i设为double型是因为后面要使用pow函数，pow函数的两个变量必须为double型。</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> u;<span class="comment">//u为求和第i项的值。</span></span><br><span class="line"><span class="comment">//注意：赋给型double型变量的值必须为double型，故要将1写作1.0。</span></span><br><span class="line"></span><br><span class="line">(<span class="type">void</span>)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n)</span><br><span class="line">&#123;</span><br><span class="line">    u = <span class="built_in">pow</span>(<span class="number">-1.0</span>, i + <span class="number">1</span>) * (<span class="number">1</span> / (<span class="number">2</span> * i - <span class="number">1</span>));</span><br><span class="line">    s = s + u;</span><br><span class="line">    i += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>, s);</span><br></pre></td></tr></table></figure>

<p>从上面的例子中可以得到解决这类问题的一般方法：</p>
<ol>
<li>声明<code>s = 0</code>（和），<code>i = 1</code>（项数），<code>u</code>（通项）</li>
<li>用<code>i</code>表示出<code>u</code>（通项）</li>
<li><code>s = s + u;</code></li>
</ol>
<p>注意使用控制结构（如<code>while</code>）使求和在第n项停止。</p>
<h3 id="约瑟夫出圈"><a href="#约瑟夫出圈" class="headerlink" title="约瑟夫出圈"></a>约瑟夫出圈</h3><p>week14第4题</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*(约瑟夫出圈 课本P220)</span></span><br><span class="line"><span class="comment">4.有n个小孩围成一圈，从1顺序排号。从第一个人开始报数（1~k报数），凡报到k的人退出圈子，</span></span><br><span class="line"><span class="comment">问最后留下的人原来排在第几号。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：人数（不超过1000），以及报数的k（不超过3000），空格分隔。</span></span><br><span class="line"><span class="comment">输出：最后留下的人的编号</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">样例输入：</span></span><br><span class="line"><span class="comment">234 3</span></span><br><span class="line"><span class="comment">样例输出：</span></span><br><span class="line"><span class="comment">230</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Josephus</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> chooseNum)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    (<span class="type">void</span>)<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, Josephus(n, k));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Josephus</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> chooseNum)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//表示小孩的数组</span></span><br><span class="line">    <span class="type">int</span> boy[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        boy[i] = i + <span class="number">1</span>; <span class="comment">//给小孩编号</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">1</span>; <span class="comment">//离开的小孩的个数</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">-1</span>; <span class="comment">//数组下标，下一个为0表示从第一个孩子开始数数</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在圈中开始剔除</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; chooseNum;)</span><br><span class="line">        &#123;</span><br><span class="line">            n = (n + <span class="number">1</span>) % num; <span class="comment">//围成一圈（可以循环）</span></span><br><span class="line">            <span class="keyword">if</span> (boy[n] != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                j++; <span class="comment">//如果该小孩还在圈中，则参加计数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">//要剔除的坐标即为n</span></span><br><span class="line">        <span class="keyword">if</span> (k == num)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//如果已经全部剔除完成，则跳出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        boy[n] = <span class="number">0</span>; <span class="comment">//剔除</span></span><br><span class="line">        k++; <span class="comment">//离开的小孩+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// break语句跳转至此，返回胜利者编号</span></span><br><span class="line">    <span class="keyword">return</span> boy[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="article-licensing box"><div class="licensing-title"><p>C语言学习笔记</p><p><a href="https://sawyershu.com/2022/02/21/C语言学习笔记/">https://sawyershu.com/2022/02/21/C语言学习笔记/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>舒予</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2022-02-21</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-09-07</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/C%E8%AF%AD%E8%A8%80/">C语言</a><a class="link-muted mr-2" rel="tag" href="/tags/%E5%A4%8D%E4%B9%A0/">复习</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/06/22/%E5%AE%9E%E5%8F%98%E5%87%BD%E6%95%B0/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">实变函数</span></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-3-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#重要的题目"><span class="level-left"><span class="level-item">1</span><span class="level-item">重要的题目</span></span></a></li><li><a class="level is-mobile" href="#注意事项"><span class="level-left"><span class="level-item">2</span><span class="level-item">注意事项</span></span></a></li><li><a class="level is-mobile" href="#常用的函数"><span class="level-left"><span class="level-item">3</span><span class="level-item">常用的函数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#数学函数"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">数学函数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#开根号"><span class="level-left"><span class="level-item">3.1.1</span><span class="level-item">开根号</span></span></a></li><li><a class="level is-mobile" href="#取整"><span class="level-left"><span class="level-item">3.1.2</span><span class="level-item">取整</span></span></a></li><li><a class="level is-mobile" href="#四舍五入"><span class="level-left"><span class="level-item">3.1.3</span><span class="level-item">四舍五入</span></span></a></li><li><a class="level is-mobile" href="#对数函数"><span class="level-left"><span class="level-item">3.1.4</span><span class="level-item">对数函数</span></span></a></li><li><a class="level is-mobile" href="#幂函数"><span class="level-left"><span class="level-item">3.1.5</span><span class="level-item">幂函数</span></span></a></li><li><a class="level is-mobile" href="#绝对值"><span class="level-left"><span class="level-item">3.1.6</span><span class="level-item">绝对值</span></span></a></li></ul></li><li><a class="level is-mobile" href="#字符串函数"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">字符串函数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#strcpy-字符串复制"><span class="level-left"><span class="level-item">3.2.1</span><span class="level-item">strcpy()字符串复制</span></span></a></li><li><a class="level is-mobile" href="#strlen-字符串长度"><span class="level-left"><span class="level-item">3.2.2</span><span class="level-item">strlen()字符串长度</span></span></a></li><li><a class="level is-mobile" href="#strcmp-字符串比较"><span class="level-left"><span class="level-item">3.2.3</span><span class="level-item">strcmp()字符串比较</span></span></a></li><li><a class="level is-mobile" href="#strcat-连接字符串"><span class="level-left"><span class="level-item">3.2.4</span><span class="level-item">strcat()连接字符串</span></span></a></li><li><a class="level is-mobile" href="#strrev反转字符串"><span class="level-left"><span class="level-item">3.2.5</span><span class="level-item">strrev反转字符串</span></span></a></li><li><a class="level is-mobile" href="#查找字符、字符串"><span class="level-left"><span class="level-item">3.2.6</span><span class="level-item">查找字符、字符串</span></span></a></li><li><a class="level is-mobile" href="#大小写字母转换"><span class="level-left"><span class="level-item">3.2.7</span><span class="level-item">大小写字母转换</span></span></a></li></ul></li><li><a class="level is-mobile" href="#动态分配函数"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">动态分配函数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#分配内存空间函数malloc"><span class="level-left"><span class="level-item">3.3.1</span><span class="level-item">分配内存空间函数malloc</span></span></a></li><li><a class="level is-mobile" href="#分配内存空间函数calloc"><span class="level-left"><span class="level-item">3.3.2</span><span class="level-item">分配内存空间函数calloc</span></span></a></li><li><a class="level is-mobile" href="#释放内存空间函数free"><span class="level-left"><span class="level-item">3.3.3</span><span class="level-item">释放内存空间函数free</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#结构体"><span class="level-left"><span class="level-item">4</span><span class="level-item">结构体</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#结构体类型的定义"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">结构体类型的定义</span></span></a></li><li><a class="level is-mobile" href="#结构体类型变量的使用"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">结构体类型变量的使用</span></span></a></li><li><a class="level is-mobile" href="#数组和结构体"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">数组和结构体</span></span></a></li></ul></li><li><a class="level is-mobile" href="#指针"><span class="level-left"><span class="level-item">5</span><span class="level-item">指针</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#指针运算"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">指针运算</span></span></a></li><li><a class="level is-mobile" href="#指针与数组"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">指针与数组</span></span></a></li></ul></li><li><a class="level is-mobile" href="#时间复杂度"><span class="level-left"><span class="level-item">6</span><span class="level-item">时间复杂度</span></span></a></li><li><a class="level is-mobile" href="#进制转换"><span class="level-left"><span class="level-item">7</span><span class="level-item">进制转换</span></span></a></li><li><a class="level is-mobile" href="#常用技巧"><span class="level-left"><span class="level-item">8</span><span class="level-item">常用技巧</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#将一个整数分解成各位数字"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">将一个整数分解成各位数字</span></span></a></li><li><a class="level is-mobile" href="#求一个整数的各位数字之和"><span class="level-left"><span class="level-item">8.2</span><span class="level-item">求一个整数的各位数字之和</span></span></a></li><li><a class="level is-mobile" href="#输出中的格式问题（如末尾的空格空行）"><span class="level-left"><span class="level-item">8.3</span><span class="level-item">输出中的格式问题（如末尾的空格空行）</span></span></a></li><li><a class="level is-mobile" href="#给函数添加注释"><span class="level-left"><span class="level-item">8.4</span><span class="level-item">给函数添加注释</span></span></a></li><li><a class="level is-mobile" href="#确定一个整数x的位数"><span class="level-left"><span class="level-item">8.5</span><span class="level-item">确定一个整数x的位数</span></span></a></li><li><a class="level is-mobile" href="#用string库函数计算一个字符出现的位置"><span class="level-left"><span class="level-item">8.6</span><span class="level-item">用string库函数计算一个字符出现的位置</span></span></a></li><li><a class="level is-mobile" href="#字母循环"><span class="level-left"><span class="level-item">8.7</span><span class="level-item">字母循环</span></span></a></li><li><a class="level is-mobile" href="#数组的循环移动"><span class="level-left"><span class="level-item">8.8</span><span class="level-item">数组的循环移动</span></span></a></li><li><a class="level is-mobile" href="#在数组中删除一个元素"><span class="level-left"><span class="level-item">8.9</span><span class="level-item">在数组中删除一个元素</span></span></a></li></ul></li><li><a class="level is-mobile" href="#经典代码"><span class="level-left"><span class="level-item">9</span><span class="level-item">经典代码</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#最大公因数-gcd-和最小公倍数-lcm"><span class="level-left"><span class="level-item">9.1</span><span class="level-item">最大公因数(gcd)和最小公倍数(lcm)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#扩展"><span class="level-left"><span class="level-item">9.1.1</span><span class="level-item">扩展</span></span></a></li></ul></li><li><a class="level is-mobile" href="#将一个整数分解为1和各个质因子的相乘"><span class="level-left"><span class="level-item">9.2</span><span class="level-item">将一个整数分解为1和各个质因子的相乘</span></span></a></li><li><a class="level is-mobile" href="#汉诺塔问题-hanoi"><span class="level-left"><span class="level-item">9.3</span><span class="level-item">汉诺塔问题(hanoi)</span></span></a></li><li><a class="level is-mobile" href="#排序算法"><span class="level-left"><span class="level-item">9.4</span><span class="level-item">排序算法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#冒泡排序"><span class="level-left"><span class="level-item">9.4.1</span><span class="level-item">冒泡排序</span></span></a></li><li><a class="level is-mobile" href="#选择排序"><span class="level-left"><span class="level-item">9.4.2</span><span class="level-item">选择排序</span></span></a></li><li><a class="level is-mobile" href="#快速排序"><span class="level-left"><span class="level-item">9.4.3</span><span class="level-item">快速排序</span></span></a></li></ul></li><li><a class="level is-mobile" href="#查找算法"><span class="level-left"><span class="level-item">9.5</span><span class="level-item">查找算法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#顺序查找"><span class="level-left"><span class="level-item">9.5.1</span><span class="level-item">顺序查找</span></span></a></li><li><a class="level is-mobile" href="#折半查找"><span class="level-left"><span class="level-item">9.5.2</span><span class="level-item">折半查找</span></span></a></li></ul></li><li><a class="level is-mobile" href="#同构数"><span class="level-left"><span class="level-item">9.6</span><span class="level-item">同构数</span></span></a></li><li><a class="level is-mobile" href="#求级数的前n项和"><span class="level-left"><span class="level-item">9.7</span><span class="level-item">求级数的前n项和</span></span></a></li><li><a class="level is-mobile" href="#约瑟夫出圈"><span class="level-left"><span class="level-item">9.8</span><span class="level-item">约瑟夫出圈</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/Sawyer.png" alt="舒予的博客" height="28"></a><p class="is-size-7"><span>&copy; 2022 舒予</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: false,
                    fold: ''
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>